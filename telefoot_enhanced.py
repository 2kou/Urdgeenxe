#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot Telegram T√©l√©foot Enhanced avec TeleFeed
Syst√®me complet de gestion de licences et de redirection de messages
"""

import os
import json
import re
import asyncio
import signal
from datetime import datetime, timedelta
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError, PhoneCodeExpiredError
from telethon.tl.types import User, Chat, Channel

# Configuration
API_ID = int(os.getenv('API_ID', '0'))
API_HASH = os.getenv('API_HASH', '')
BOT_TOKEN = os.getenv('BOT_TOKEN', '')
ADMIN_ID = int(os.getenv('ADMIN_ID', '0'))

# Plans de licence
PLANS = {
    'weekly': {'duration': 7, 'price': 1000},
    'monthly': {'duration': 30, 'price': 3000}
}

# Donn√©es globales
users = {}
telefeed_sessions = {}
telefeed_redirections = {}
telefeed_transformations = {}
telefeed_whitelist = {}
telefeed_blacklist = {}
telefeed_settings = {}
telefeed_chats = {}
telefeed_clients = {}
pending_connections = {}

def load_json(filename):
    """Charge un fichier JSON"""
    try:
        if os.path.exists(filename):
            with open(filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    except:
        return {}

def save_json(filename, data):
    """Sauvegarde un fichier JSON"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        return True
    except:
        return False

def load_all_data():
    """Charge toutes les donn√©es"""
    global users, telefeed_sessions, telefeed_redirections, telefeed_transformations
    global telefeed_whitelist, telefeed_blacklist, telefeed_settings, telefeed_chats
    
    users = load_json('users.json')
    telefeed_sessions = load_json('telefeed_sessions.json')
    telefeed_redirections = load_json('telefeed_redirections.json')
    telefeed_transformations = load_json('telefeed_transformations.json')
    telefeed_whitelist = load_json('telefeed_whitelist.json')
    telefeed_blacklist = load_json('telefeed_blacklist.json')
    telefeed_settings = load_json('telefeed_settings.json')
    telefeed_chats = load_json('telefeed_chats.json')

def save_all_data():
    """Sauvegarde toutes les donn√©es"""
    save_json('users.json', users)
    save_json('telefeed_sessions.json', telefeed_sessions)
    save_json('telefeed_redirections.json', telefeed_redirections)
    save_json('telefeed_transformations.json', telefeed_transformations)
    save_json('telefeed_whitelist.json', telefeed_whitelist)
    save_json('telefeed_blacklist.json', telefeed_blacklist)
    save_json('telefeed_settings.json', telefeed_settings)
    save_json('telefeed_chats.json', telefeed_chats)

def is_user_active(user_id):
    """V√©rifie si un utilisateur a une licence active"""
    user_data = users.get(str(user_id))
    if not user_data or user_data.get('status') != 'active':
        return False
    
    expire_date = user_data.get('expires')
    if expire_date:
        expire_datetime = datetime.fromisoformat(expire_date)
        return datetime.now() < expire_datetime
    return False

def activate_user(user_id, plan):
    """Active un utilisateur avec un plan"""
    if plan not in PLANS:
        return False
    
    user_id = str(user_id)
    if user_id not in users:
        users[user_id] = {}
    
    duration = PLANS[plan]['duration']
    expires = datetime.now() + timedelta(days=duration)
    
    users[user_id].update({
        'status': 'active',
        'plan': plan,
        'expires': expires.isoformat(),
        'activated_at': datetime.now().isoformat()
    })
    
    save_all_data()
    return True

def get_user_info(user_id):
    """R√©cup√®re les informations d'un utilisateur"""
    return users.get(str(user_id))

def apply_transformations(text, phone_number, redirection_id):
    """Applique les transformations sur le texte"""
    if not text:
        return text
    
    # Format transformation
    format_data = telefeed_transformations.get(phone_number, {}).get(redirection_id, {}).get('format')
    if format_data:
        template = format_data.get('template', '[[Message.Text]]')
        text = template.replace('[[Message.Text]]', text)
    
    # Power transformation
    power_data = telefeed_transformations.get(phone_number, {}).get(redirection_id, {}).get('power')
    if power_data:
        rules = power_data.get('rules', [])
        for rule in rules:
            if '=' in rule:
                pattern, replacement = rule.split('=', 1)
                try:
                    text = re.sub(pattern, replacement, text, flags=re.MULTILINE | re.DOTALL)
                except:
                    pass
            elif '","' in rule:
                rule = rule.strip('"')
                if '","' in rule:
                    old, new = rule.split('","', 1)
                    text = text.replace(old, new)
    
    # Remove lines transformation
    remove_lines_data = telefeed_transformations.get(phone_number, {}).get(redirection_id, {}).get('removeLines')
    if remove_lines_data:
        keywords = remove_lines_data.get('keywords', [])
        lines = text.split('\n')
        filtered_lines = []
        
        for line in lines:
            should_remove = False
            for keyword in keywords:
                if keyword in line:
                    should_remove = True
                    break
            if not should_remove:
                filtered_lines.append(line)
        
        text = '\n'.join(filtered_lines)
    
    return text

def should_process_message(text, phone_number, redirection_id):
    """V√©rifie si le message doit √™tre trait√©"""
    # V√©rifier la blacklist
    blacklist_data = telefeed_blacklist.get(phone_number, {}).get(redirection_id, {})
    if blacklist_data and blacklist_data.get('active', False):
        patterns = blacklist_data.get('patterns', [])
        for pattern in patterns:
            if isinstance(pattern, str):
                if pattern.startswith('"') and pattern.endswith('"'):
                    if pattern[1:-1] in text:
                        return False
                else:
                    try:
                        if re.search(pattern, text, re.MULTILINE | re.DOTALL):
                            return False
                    except:
                        pass
    
    # V√©rifier la whitelist
    whitelist_data = telefeed_whitelist.get(phone_number, {}).get(redirection_id, {})
    if whitelist_data and whitelist_data.get('active', False):
        patterns = whitelist_data.get('patterns', [])
        if patterns:
            for pattern in patterns:
                if isinstance(pattern, str):
                    if pattern.startswith('"') and pattern.endswith('"'):
                        if pattern[1:-1] in text:
                            return True
                    else:
                        try:
                            if re.search(pattern, text, re.MULTILINE | re.DOTALL):
                                return True
                        except:
                            pass
            return False
    
    return True

# Cr√©er le client bot
bot = TelegramClient('telefeed_bot', API_ID, API_HASH)

@bot.on(events.NewMessage(pattern='/start'))
async def start_handler(event):
    """Commande /start"""
    user_id = str(event.sender_id)
    
    if user_id not in users:
        users[user_id] = {
            'status': 'waiting',
            'registered_at': datetime.now().isoformat()
        }
        save_all_data()
    
    welcome_message = (
        "üöÄ **Bienvenue sur T√©l√©foot Enhanced !**\n\n"
        "üéØ **Fonctionnalit√©s :**\n"
        "‚Ä¢ Pronostics football quotidiens\n"
        "‚Ä¢ Syst√®me TeleFeed complet\n"
        "‚Ä¢ Redirection de messages\n"
        "‚Ä¢ Transformations avanc√©es\n\n"
        "üí∞ **Tarifs :**\n"
        "‚Ä¢ 1 semaine = 1000f\n"
        "‚Ä¢ 1 mois = 3000f\n\n"
        "üìû **Contact :** @SossouKouame\n"
        "üîë **Commandes :** /help"
    )
    
    await event.reply(welcome_message, parse_mode='markdown')

@bot.on(events.NewMessage(pattern='/help'))
async def help_handler(event):
    """Commande /help"""
    help_message = (
        "ü§ñ **Commandes disponibles :**\n\n"
        "**üìã G√©n√©ral :**\n"
        "‚Ä¢ /start - D√©marrer le bot\n"
        "‚Ä¢ /status - Voir votre statut\n"
        "‚Ä¢ /help - Afficher cette aide\n\n"
        "**üöÄ TeleFeed (Utilisateurs actifs) :**\n"
        "‚Ä¢ /connect <num√©ro> - Connecter un compte\n"
        "‚Ä¢ /chats <num√©ro> - Voir les chats\n"
        "‚Ä¢ /redirection add <nom> on <num√©ro> - Ajouter redirection\n"
        "‚Ä¢ /redirection remove <nom> on <num√©ro> - Supprimer\n"
        "‚Ä¢ /redirection <num√©ro> - Lister les redirections\n"
        "‚Ä¢ /transformation add <type> <nom> on <num√©ro> - Transformer\n"
        "‚Ä¢ /whitelist add <nom> on <num√©ro> - Filtrer\n"
        "‚Ä¢ /blacklist add <nom> on <num√©ro> - Bloquer\n\n"
        "**üí° Exemple complet :**\n"
        "1. `/connect 33123456789`\n"
        "2. `aa12345` (code re√ßu)\n"
        "3. `/chats 33123456789`\n"
        "4. `/redirection add test on 33123456789`\n"
        "5. `123456789 - 987654321`\n\n"
        "**üìû Support :** @SossouKouame"
    )
    
    await event.reply(help_message, parse_mode='markdown')

@bot.on(events.NewMessage(pattern='/status'))
async def status_handler(event):
    """Commande /status"""
    user_id = str(event.sender_id)
    
    if event.sender_id == ADMIN_ID:
        parts = event.raw_text.split()
        if len(parts) == 2:
            target_user_id = parts[1]
            user_info = get_user_info(target_user_id)
            if user_info:
                active = "‚úÖ Actif" if is_user_active(target_user_id) else "‚ùå Expir√©"
                message = (
                    f"üìä **Utilisateur {target_user_id}**\n"
                    f"üîÑ Statut : {active}\n"
                    f"üìã Plan : {user_info.get('plan', 'N/A')}\n"
                    f"‚è∞ Expire : {user_info.get('expires', 'N/A')}\n"
                    f"üìÖ Activ√© : {user_info.get('activated_at', 'N/A')}"
                )
                await event.reply(message, parse_mode='markdown')
            else:
                await event.reply("‚ùå Utilisateur non trouv√©")
            return
    
    # Statut personnel
    user_info = get_user_info(user_id)
    if not user_info:
        await event.reply("‚ùå Vous n'√™tes pas enregistr√©. Contactez l'administrateur.")
        return
    
    active = "‚úÖ Actif" if is_user_active(user_id) else "‚ùå Expir√©"
    message = (
        f"üìä **Votre statut**\n"
        f"üîÑ Statut : {active}\n"
        f"üìã Plan : {user_info.get('plan', 'N/A')}\n"
        f"‚è∞ Expire : {user_info.get('expires', 'N/A')}\n"
        f"üìÖ Activ√© : {user_info.get('activated_at', 'N/A')}"
    )
    
    await event.reply(message, parse_mode='markdown')

@bot.on(events.NewMessage(pattern=r'/activer (\w+) (\w+)'))
async def activer_handler(event):
    """Commande /activer (admin seulement)"""
    if event.sender_id != ADMIN_ID:
        await event.reply("‚ùå Commande r√©serv√©e aux administrateurs")
        return
    
    user_id = event.pattern_match.group(1)
    plan = event.pattern_match.group(2)
    
    if plan not in PLANS:
        await event.reply("‚ùå Plan invalide. Utilisez: weekly ou monthly")
        return
    
    if activate_user(user_id, plan):
        duration = PLANS[plan]['duration']
        price = PLANS[plan]['price']
        
        await event.reply(
            f"‚úÖ **Utilisateur {user_id} activ√© !**\n"
            f"üìã Plan : {plan}\n"
            f"‚è∞ Dur√©e : {duration} jours\n"
            f"üí∞ Prix : {price}f"
        )
        
        # Notifier l'utilisateur
        try:
            await bot.send_message(
                int(user_id),
                f"üéâ **Votre licence a √©t√© activ√©e !**\n"
                f"üìã Plan : {plan}\n"
                f"‚è∞ Dur√©e : {duration} jours\n"
                f"üöÄ Vous avez maintenant acc√®s √† toutes les fonctionnalit√©s TeleFeed !"
            )
        except:
            pass
    else:
        await event.reply("‚ùå Erreur lors de l'activation")

@bot.on(events.NewMessage(pattern=r'/connect (\d+)'))
async def connect_handler(event):
    """Commande /connect"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    phone_number = event.pattern_match.group(1)
    
    await event.reply("üîå Connexion en cours...")
    
    try:
        session_name = f"telefeed_{phone_number}"
        client = TelegramClient(session_name, API_ID, API_HASH)
        
        await client.connect()
        
        if not await client.is_user_authorized():
            result = await client.send_code_request(phone_number)
            
            # Stocker temporairement
            pending_connections[event.sender_id] = {
                'phone_number': phone_number,
                'phone_code_hash': result.phone_code_hash,
                'client': client
            }
            
            await event.reply(
                f"üì± Code envoy√© √† {phone_number}\n"
                f"üí° R√©pondez avec: aa + votre code\n"
                f"üìù Exemple: aa12345"
            )
        else:
            telefeed_clients[phone_number] = client
            telefeed_sessions[phone_number] = {
                'connected': True,
                'connected_at': datetime.now().isoformat()
            }
            save_all_data()
            await event.reply(f"‚úÖ Compte {phone_number} connect√© avec succ√®s!")
            
    except Exception as e:
        await event.reply(f"‚ùå Erreur: {str(e)}")

@bot.on(events.NewMessage(pattern=r'^aa(\d+)$'))
async def verify_code_handler(event):
    """V√©rification du code TeleFeed"""
    if not is_user_active(event.sender_id):
        return
    
    if event.sender_id not in pending_connections:
        await event.reply("‚ùå Aucune connexion en attente.")
        return
    
    code = event.pattern_match.group(1)
    connection_data = pending_connections[event.sender_id]
    
    try:
        await connection_data['client'].sign_in(
            connection_data['phone_number'],
            code,
            phone_code_hash=connection_data['phone_code_hash']
        )
        
        phone_number = connection_data['phone_number']
        telefeed_clients[phone_number] = connection_data['client']
        telefeed_sessions[phone_number] = {
            'connected': True,
            'connected_at': datetime.now().isoformat()
        }
        save_all_data()
        
        del pending_connections[event.sender_id]
        
        await event.reply(f"‚úÖ Compte {phone_number} connect√© avec succ√®s!")
        
    except SessionPasswordNeededError:
        await event.reply("üîê Authentification 2FA requise. Envoyez votre mot de passe.")
    except Exception as e:
        await event.reply(f"‚ùå Erreur: {str(e)}")

@bot.on(events.NewMessage(pattern=r'/chats (\d+)'))
async def chats_handler(event):
    """Commande /chats"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    phone_number = event.pattern_match.group(1)
    
    if phone_number not in telefeed_clients:
        await event.reply(f"‚ùå Compte {phone_number} non connect√©. Utilisez /connect {phone_number}")
        return
    
    await event.reply("üìã R√©cup√©ration des chats...")
    
    try:
        client = telefeed_clients[phone_number]
        chats = []
        
        async for dialog in client.iter_dialogs(limit=50):
            chat_type = 'unknown'
            if isinstance(dialog.entity, User):
                chat_type = 'user'
            elif isinstance(dialog.entity, Chat):
                chat_type = 'group'
            elif isinstance(dialog.entity, Channel):
                chat_type = 'channel' if dialog.entity.broadcast else 'supergroup'
            
            chats.append({
                'id': dialog.id,
                'title': dialog.title or dialog.name,
                'type': chat_type
            })
        
        if not chats:
            await event.reply("üì≠ Aucun chat trouv√©.")
            return
        
        # Sauvegarder
        telefeed_chats[phone_number] = chats
        save_all_data()
        
        message = "üìã **Chats disponibles:**\n\n"
        for chat in chats[:15]:  # Limiter √† 15 chats
            emoji = "üë§" if chat['type'] == 'user' else "üë•" if chat['type'] == 'group' else "üì¢"
            message += f"{emoji} `{chat['id']}` - {chat['title']} ({chat['type']})\n"
        
        if len(chats) > 15:
            message += f"\n... et {len(chats) - 15} autres chats"
        
        await event.reply(message, parse_mode='markdown')
        
    except Exception as e:
        await event.reply(f"‚ùå Erreur: {str(e)}")

@bot.on(events.NewMessage(pattern=r'/redirection add (\w+) on (\d+)'))
async def add_redirection_handler(event):
    """Commande /redirection add"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    redirection_id = event.pattern_match.group(1)
    phone_number = event.pattern_match.group(2)
    
    await event.reply(
        f"üîÑ Configuration de la redirection **{redirection_id}**\n\n"
        f"üìù Envoyez maintenant les IDs au format:\n"
        f"**SOURCE - DESTINATION**\n\n"
        f"üìã Exemples:\n"
        f"‚Ä¢ `123456789 - 987654321`\n"
        f"‚Ä¢ `123,456 - 789,012`\n"
        f"‚Ä¢ Utilisez /chats {phone_number} pour voir les IDs",
        parse_mode='markdown'
    )
    
    # Attendre la r√©ponse
    def check_response(new_event):
        return (new_event.sender_id == event.sender_id and 
                new_event.chat_id == event.chat_id and 
                ' - ' in new_event.raw_text)
    
    try:
        response = await bot.wait_for(events.NewMessage(func=check_response), timeout=60)
        
        # Parser la r√©ponse
        parts = response.raw_text.split(' - ')
        if len(parts) != 2:
            await event.reply("‚ùå Format invalide. Utilisez: SOURCE - DESTINATION")
            return
        
        sources = [int(x.strip()) for x in parts[0].split(',')]
        destinations = [int(x.strip()) for x in parts[1].split(',')]
        
        # Ajouter la redirection
        if phone_number not in telefeed_redirections:
            telefeed_redirections[phone_number] = {}
        
        telefeed_redirections[phone_number][redirection_id] = {
            'sources': sources,
            'destinations': destinations,
            'created_at': datetime.now().isoformat(),
            'active': True
        }
        
        # Param√®tres par d√©faut
        if phone_number not in telefeed_settings:
            telefeed_settings[phone_number] = {}
        
        telefeed_settings[phone_number][redirection_id] = {
            'process_reply': True,
            'process_edit': True,
            'process_delete': True,
            'process_me': False,
            'process_forward': False,
            'process_raw': False,
            'process_duplicates': True,
            'delay_spread_mode': False
        }
        
        save_all_data()
        await event.reply(f"‚úÖ Redirection **{redirection_id}** cr√©√©e avec succ√®s!")
        
    except asyncio.TimeoutError:
        await event.reply("‚è∞ Timeout. Recommencez la configuration.")
    except ValueError:
        await event.reply("‚ùå IDs invalides. Utilisez uniquement des nombres.")

@bot.on(events.NewMessage(pattern=r'/redirection remove (\w+) on (\d+)'))
async def remove_redirection_handler(event):
    """Commande /redirection remove"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    redirection_id = event.pattern_match.group(1)
    phone_number = event.pattern_match.group(2)
    
    if (phone_number in telefeed_redirections and 
        redirection_id in telefeed_redirections[phone_number]):
        del telefeed_redirections[phone_number][redirection_id]
        
        if (phone_number in telefeed_settings and 
            redirection_id in telefeed_settings[phone_number]):
            del telefeed_settings[phone_number][redirection_id]
        
        save_all_data()
        await event.reply(f"‚úÖ Redirection **{redirection_id}** supprim√©e.")
    else:
        await event.reply("‚ùå Redirection non trouv√©e.")

@bot.on(events.NewMessage(pattern=r'/redirection (\d+)'))
async def list_redirections_handler(event):
    """Commande /redirection (lister)"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    phone_number = event.pattern_match.group(1)
    
    redirections = telefeed_redirections.get(phone_number, {})
    
    if not redirections:
        await event.reply(f"üì≠ Aucune redirection active pour {phone_number}")
        return
    
    message = f"üîÑ **Redirections actives pour {phone_number}:**\n\n"
    
    for redir_id, data in redirections.items():
        status = "‚úÖ" if data.get('active', True) else "‚ùå"
        sources = ', '.join(map(str, data.get('sources', [])))
        destinations = ', '.join(map(str, data.get('destinations', [])))
        
        message += f"{status} **{redir_id}**\n"
        message += f"üì§ Sources: `{sources}`\n"
        message += f"üì• Destinations: `{destinations}`\n\n"
    
    await event.reply(message, parse_mode='markdown')

@bot.on(events.NewMessage(pattern=r'/transformation add (\w+) (\w+) on (\d+)'))
async def add_transformation_handler(event):
    """Commande /transformation add"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    feature = event.pattern_match.group(1)
    redirection_id = event.pattern_match.group(2)
    phone_number = event.pattern_match.group(3)
    
    if feature not in ['format', 'power', 'removeLines']:
        await event.reply("‚ùå Fonctionnalit√© non support√©e. Utilisez: format, power, removeLines")
        return
    
    await event.reply(
        f"‚öôÔ∏è Configuration de la transformation **{feature}** pour **{redirection_id}**\n\n"
        f"üìù Envoyez maintenant votre configuration:"
    )
    
    # Attendre la r√©ponse
    def check_response(new_event):
        return (new_event.sender_id == event.sender_id and 
                new_event.chat_id == event.chat_id)
    
    try:
        response = await bot.wait_for(events.NewMessage(func=check_response), timeout=120)
        
        # Initialiser la structure
        if phone_number not in telefeed_transformations:
            telefeed_transformations[phone_number] = {}
        if redirection_id not in telefeed_transformations[phone_number]:
            telefeed_transformations[phone_number][redirection_id] = {}
        
        # Configurer selon le type
        if feature == 'format':
            telefeed_transformations[phone_number][redirection_id]['format'] = {
                'template': response.raw_text,
                'active': True
            }
        elif feature == 'power':
            rules = response.raw_text.split('\n')
            telefeed_transformations[phone_number][redirection_id]['power'] = {
                'rules': rules,
                'active': True
            }
        elif feature == 'removeLines':
            keywords = [k.strip() for k in response.raw_text.split(',')]
            telefeed_transformations[phone_number][redirection_id]['removeLines'] = {
                'keywords': keywords,
                'active': True
            }
        
        save_all_data()
        await event.reply(f"‚úÖ Transformation **{feature}** configur√©e pour **{redirection_id}**!")
        
    except asyncio.TimeoutError:
        await event.reply("‚è∞ Timeout. Recommencez la configuration.")

@bot.on(events.NewMessage(pattern=r'/whitelist add (\w+) on (\d+)'))
async def add_whitelist_handler(event):
    """Commande /whitelist add"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    redirection_id = event.pattern_match.group(1)
    phone_number = event.pattern_match.group(2)
    
    await event.reply(
        f"‚ö™ Configuration de la whitelist pour **{redirection_id}**\n\n"
        f"üìù Envoyez les mots-cl√©s (un par ligne):"
    )
    
    def check_response(new_event):
        return (new_event.sender_id == event.sender_id and 
                new_event.chat_id == event.chat_id)
    
    try:
        response = await bot.wait_for(events.NewMessage(func=check_response), timeout=60)
        
        patterns = response.raw_text.split('\n')
        
        if phone_number not in telefeed_whitelist:
            telefeed_whitelist[phone_number] = {}
        
        telefeed_whitelist[phone_number][redirection_id] = {
            'patterns': patterns,
            'active': True
        }
        
        save_all_data()
        await event.reply(f"‚úÖ Whitelist configur√©e pour **{redirection_id}**!")
        
    except asyncio.TimeoutError:
        await event.reply("‚è∞ Timeout. Recommencez la configuration.")

@bot.on(events.NewMessage(pattern=r'/blacklist add (\w+) on (\d+)'))
async def add_blacklist_handler(event):
    """Commande /blacklist add"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
        return
    
    redirection_id = event.pattern_match.group(1)
    phone_number = event.pattern_match.group(2)
    
    await event.reply(
        f"‚ö´ Configuration de la blacklist pour **{redirection_id}**\n\n"
        f"üìù Envoyez les mots-cl√©s √† bloquer (un par ligne):"
    )
    
    def check_response(new_event):
        return (new_event.sender_id == event.sender_id and 
                new_event.chat_id == event.chat_id)
    
    try:
        response = await bot.wait_for(events.NewMessage(func=check_response), timeout=60)
        
        patterns = response.raw_text.split('\n')
        
        if phone_number not in telefeed_blacklist:
            telefeed_blacklist[phone_number] = {}
        
        telefeed_blacklist[phone_number][redirection_id] = {
            'patterns': patterns,
            'active': True
        }
        
        save_all_data()
        await event.reply(f"‚úÖ Blacklist configur√©e pour **{redirection_id}**!")
        
    except asyncio.TimeoutError:
        await event.reply("‚è∞ Timeout. Recommencez la configuration.")

@bot.on(events.NewMessage(pattern='/pronostics'))
async def pronostics_handler(event):
    """Commande /pronostics"""
    if not is_user_active(event.sender_id):
        await event.reply("‚ùå Vous devez avoir une licence active pour voir les pronostics.")
        return
    
    pronostics = (
        f"‚öΩ **Pronostics du jour - {datetime.now().strftime('%d/%m/%Y')}**\n\n"
        f"üèÜ **Ligue 1 :**\n"
        f"‚Ä¢ PSG vs Lyon : 1 @1.85 ‚úÖ\n"
        f"‚Ä¢ Marseille vs Nice : X @3.20 üî•\n"
        f"‚Ä¢ Monaco vs Lille : 2 @2.45 üíé\n\n"
        f"üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø **Premier League :**\n"
        f"‚Ä¢ Man City vs Chelsea : 1 @1.75 ‚úÖ\n"
        f"‚Ä¢ Liverpool vs Arsenal : Plus 2.5 @1.90 üî•\n"
        f"‚Ä¢ Tottenham vs Man Utd : X @3.45 üíé\n\n"
        f"üá™üá∏ **La Liga :**\n"
        f"‚Ä¢ Real Madrid vs Barcelona : 1 @2.10 ‚úÖ\n"
        f"‚Ä¢ Atletico vs Sevilla : Moins 2.5 @1.95 üî•\n"
        f"‚Ä¢ Valencia vs Villarreal : 2 @2.30 üíé\n\n"
        f"üìä **Statistiques :**\n"
        f"‚Ä¢ Taux de r√©ussite : 78%\n"
        f"‚Ä¢ Profit cette semaine : +15 unit√©s\n"
        f"‚Ä¢ Meilleur pari : PSG vs Lyon ‚úÖ\n\n"
        f"üî• **Pari du jour :** PSG vs Lyon - 1 @1.85\n"
        f"üí∞ **Mise conseill√©e :** 3 unit√©s\n"
        f"‚è∞ **Derni√®re mise √† jour :** {datetime.now().strftime('%H:%M')}"
    )
    
    await event.reply(pronostics, parse_mode='markdown')

# Handler pour les messages redirig√©s
@bot.on(events.NewMessage)
async def handle_message_redirection(event):
    """Gestionnaire principal pour les redirections"""
    # V√©rifier tous les comptes connect√©s
    for phone_number, client in telefeed_clients.items():
        if client == event.client:
            # V√©rifier les redirections pour ce num√©ro
            redirections = telefeed_redirections.get(phone_number, {})
            
            for redir_id, redir_data in redirections.items():
                if not redir_data.get('active', True):
                    continue
                
                # V√©rifier si ce chat est dans les sources
                if event.chat_id in redir_data.get('sources', []):
                    text = event.raw_text or ''
                    
                    # V√©rifier les filtres
                    if not should_process_message(text, phone_number, redir_id):
                        continue
                    
                    # Appliquer les transformations
                    processed_text = apply_transformations(text, phone_number, redir_id)
                    
                    # Envoyer vers les destinations
                    for dest_id in redir_data.get('destinations', []):
                        try:
                            await client.send_message(dest_id, processed_text)
                        except Exception as e:
                            print(f"Erreur lors de l'envoi vers {dest_id}: {e}")

async def main():
    """Fonction principale"""
    print("üöÄ T√©l√©foot Enhanced - Chargement...")
    
    # Charger les donn√©es
    load_all_data()
    
    # D√©marrer le bot
    await bot.start(bot_token=BOT_TOKEN)
    
    # V√©rifier la connexion
    me = await bot.get_me()
    print(f"ü§ñ Bot connect√© : @{me.username}")
    
    print("‚úÖ T√©l√©foot Enhanced d√©marr√© avec succ√®s!")
    print("üöÄ Fonctionnalit√©s TeleFeed activ√©es")
    print("üì± En attente de messages...")
    
    # Boucle principale
    try:
        await bot.run_until_disconnected()
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Arr√™t du bot demand√©")
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
    finally:
        # Nettoyer les clients
        for client in telefeed_clients.values():
            await client.disconnect()
        print("üîå Clients d√©connect√©s")

if __name__ == "__main__":
    asyncio.run(main())