"""
TeleFeed Commands Implementation for T√©l√©foot Bot
Integrates advanced message redirection and transformation features
"""

import json
import os
import re
import asyncio
from datetime import datetime
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError, PhoneCodeExpiredError
from telethon.tl.types import User, Chat, Channel

# Configuration des admins
ADMIN_IDS = ['1190237801']  # ID admin principal

# Configuration des fichiers de donn√©es
DATA_FILES = {
    'sessions': 'telefeed_sessions.json',
    'redirections': 'telefeed_redirections.json',
    'transformations': 'telefeed_transformations.json',
    'filters': 'telefeed_filters.json',
    'whitelist': 'telefeed_whitelist.json',
    'blacklist': 'telefeed_blacklist.json',
    'settings': 'telefeed_settings.json',
    'chats': 'telefeed_chats.json',
    'delay': 'telefeed_delay.json'
}

def load_json_data(filename):
    """Charge les donn√©es JSON"""
    try:
        if os.path.exists(filename):
            with open(filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    except Exception as e:
        print(f"Erreur lors du chargement {filename}: {e}")
        return {}

def save_json_data(filename, data):
    """Sauvegarde les donn√©es JSON"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        return True
    except Exception as e:
        print(f"Erreur lors de la sauvegarde {filename}: {e}")
        return False

def is_user_authorized(user_id):
    """V√©rifie si l'utilisateur est autoris√© (a une licence active)"""
    try:
        with open('users.json', 'r', encoding='utf-8') as f:
            users = json.load(f)
        
        user_data = users.get(str(user_id))
        if not user_data:
            return False
            
        if user_data.get('status') != 'active':
            return False
            
        # V√©rifier l'expiration
        expire_date = user_data.get('expires')
        if expire_date:
            expire_datetime = datetime.fromisoformat(expire_date)
            if datetime.now() > expire_datetime:
                return False
                
        return True
    except:
        return False

class TeleFeedManager:
    """Gestionnaire principal pour les fonctionnalit√©s TeleFeed"""
    
    def __init__(self):
        self.sessions = load_json_data(DATA_FILES['sessions'])
        self.redirections = load_json_data(DATA_FILES['redirections'])
        self.transformations = load_json_data(DATA_FILES['transformations'])
        self.filters = load_json_data(DATA_FILES['filters'])
        self.whitelist = load_json_data(DATA_FILES['whitelist'])
        self.blacklist = load_json_data(DATA_FILES['blacklist'])
        self.settings = load_json_data(DATA_FILES['settings'])
        self.chats = load_json_data(DATA_FILES['chats'])
        self.delay = load_json_data(DATA_FILES['delay'])
        
        # Mapping des messages pour √©dition
        self.message_mapping = load_json_data('telefeed_message_mapping.json')
        
        # Clients connect√©s
        self.clients = {}
        
        # Note: La restauration des sessions se fait lors du premier appel
        
    def save_all_data(self):
        """Sauvegarde toutes les donn√©es"""
        # Filtrer les sessions pour exclure les clients TelegramClient
        sessions_to_save = {}
        for phone, session_data in self.sessions.items():
            if isinstance(session_data, dict):
                # Cr√©er une copie sans les objets TelegramClient
                filtered_session = {k: v for k, v in session_data.items() if k != 'client'}
                sessions_to_save[phone] = filtered_session
            else:
                sessions_to_save[phone] = session_data
        
        save_json_data(DATA_FILES['sessions'], sessions_to_save)
        save_json_data(DATA_FILES['redirections'], self.redirections)
        save_json_data(DATA_FILES['transformations'], self.transformations)
        save_json_data(DATA_FILES['filters'], self.filters)
        save_json_data(DATA_FILES['whitelist'], self.whitelist)
        save_json_data(DATA_FILES['blacklist'], self.blacklist)
        save_json_data(DATA_FILES['settings'], self.settings)
        save_json_data(DATA_FILES['chats'], self.chats)
        save_json_data(DATA_FILES['delay'], self.delay)
        save_json_data('telefeed_message_mapping.json', self.message_mapping)
    
    async def restore_existing_sessions(self):
        """Restaure automatiquement les sessions existantes"""
        print("üîÑ Restauration des sessions existantes...")
        
        for phone_number, session_data in self.sessions.items():
            if isinstance(session_data, dict) and session_data.get('connected'):
                try:
                    # Cr√©er le client avec le nom de session existant
                    session_name = f"telefeed_{phone_number}"
                    
                    # V√©rifier si le fichier de session existe
                    if os.path.exists(f"{session_name}.session"):
                        # Utiliser API_ID et API_HASH par d√©faut (peuvent √™tre modifi√©s)
                        from config import API_ID, API_HASH
                        client = TelegramClient(session_name, API_ID, API_HASH)
                        
                        await client.connect()
                        
                        # V√©rifier si la session est toujours valide
                        if await client.is_user_authorized():
                            self.clients[phone_number] = client
                            # Marquer la session comme restaur√©e
                            self.sessions[phone_number]['restored_at'] = datetime.now().isoformat()
                            print(f"‚úÖ Session restaur√©e pour {phone_number}")
                        else:
                            print(f"‚ö†Ô∏è Session expir√©e pour {phone_number}")
                            # Marquer la session comme expir√©e
                            self.sessions[phone_number]['connected'] = False
                            self.sessions[phone_number]['expired_at'] = datetime.now().isoformat()
                            pass
                    else:
                        print(f"‚ö†Ô∏è Fichier de session manquant pour {phone_number}")
                        # Marquer la session comme manquante
                        self.sessions[phone_number]['connected'] = False
                        self.sessions[phone_number]['missing_file'] = True
                        
                except Exception as e:
                    print(f"‚ùå Erreur lors de la restauration de {phone_number}: {e}")
                    # Marquer la session comme en erreur
                    self.sessions[phone_number]['connected'] = False
                    self.sessions[phone_number]['error'] = str(e)
        
        # Sauvegarder les changements
        self.save_all_data()
        print(f"üîÑ {len(self.clients)} sessions restaur√©es")
    
    async def setup_redirection_handlers(self, client, phone_number):
        """Configure les gestionnaires de redirection pour un client TeleFeed"""
        from telethon import events
        
        async def message_handler(event, is_edit=False):
            """Gestionnaire des messages pour redirection"""
            # V√©rifier les redirections pour ce num√©ro
            redirections = self.redirections.get(phone_number, {})
            
            for redir_id, redir_data in redirections.items():
                if not redir_data.get('active', True):
                    continue
                
                # V√©rifier si ce chat est dans les sources
                if event.chat_id in redir_data.get('sources', []):
                    text = event.raw_text or ''
                    
                    # V√©rifier les filtres
                    if not self.should_process_message(text, phone_number, redir_id):
                        continue
                    
                    # Appliquer les transformations
                    processed_text = self.apply_transformations(text, phone_number, redir_id)
                    
                    # Envoyer vers les destinations
                    for dest_id in redir_data.get('destinations', []):
                        try:
                            # Cl√© unique pour ce message source
                            source_key = f"{event.chat_id}_{event.id}"
                            
                            if is_edit:
                                # Message √©dit√© - essayer de modifier le message existant
                                dest_message_id = self.message_mapping.get(source_key, {}).get(str(dest_id))
                                if dest_message_id:
                                    try:
                                        # √âditer en tant que canal/groupe
                                        await client.edit_message(
                                            dest_id, 
                                            dest_message_id, 
                                            processed_text,
                                            schedule=None
                                        )
                                        print(f"‚úÖ Message √©dit√© dans {dest_id}")
                                        continue
                                    except Exception as e:
                                        print(f"‚ö†Ô∏è Impossible d'√©diter: {e}")
                                        # Si l'√©dition √©choue, ne pas envoyer un nouveau message
                                        continue
                                else:
                                    # Pas de correspondance trouv√©e pour ce message √©dit√©
                                    print(f"‚ö†Ô∏è Aucune correspondance trouv√©e pour √©dition {source_key}")
                                    continue
                            else:
                                # Nouveau message - envoyer AUTHENTIQUEMENT comme le canal de destination
                                try:
                                    # Obtenir l'entit√© du canal de destination
                                    destination_entity = await client.get_entity(dest_id)
                                    
                                    # V√©rifier les permissions d'administrateur
                                    try:
                                        permissions = await client.get_permissions(destination_entity, 'me')
                                        can_post_as_channel = (
                                            permissions.is_admin and 
                                            (hasattr(permissions, 'post_messages') and permissions.post_messages) or
                                            (hasattr(permissions, 'send_messages') and permissions.send_messages)
                                        )
                                        print(f"üîç Permissions pour {destination_entity.title}: Admin={permissions.is_admin}, Post={getattr(permissions, 'post_messages', 'N/A')}")
                                    except Exception as perm_error:
                                        print(f"‚ö†Ô∏è Erreur permissions: {perm_error}")
                                        can_post_as_channel = False
                                    
                                    # M√âTHODE 1 : Envoyer comme le canal lui-m√™me
                                    if can_post_as_channel:
                                        # Essayer diff√©rentes m√©thodes pour envoyer authentiquement
                                        authentic_success = False
                                        
                                        # M√âTHODE 1: Utiliser send_message avec from_peer
                                        try:
                                            sent_message = await client.send_message(
                                                destination_entity,
                                                processed_text,
                                                from_peer=destination_entity
                                            )
                                            authentic_success = True
                                            print(f"‚úÖ Message authentique envoy√© par canal {destination_entity.title}")
                                            
                                        except Exception as from_peer_error:
                                            print(f"‚ö†Ô∏è √âchec from_peer: {from_peer_error}")
                                            
                                            # M√âTHODE 2: Utiliser l'API low-level
                                            try:
                                                from telethon.tl.functions.messages import SendMessageRequest
                                                
                                                result = await client(SendMessageRequest(
                                                    peer=destination_entity,
                                                    message=processed_text,
                                                    silent=False
                                                ))
                                                
                                                # Extraire le message depuis la r√©ponse
                                                sent_message = None
                                                if hasattr(result, 'updates'):
                                                    for update in result.updates:
                                                        if hasattr(update, 'message'):
                                                            sent_message = update.message
                                                            break
                                                
                                                if sent_message:
                                                    authentic_success = True
                                                    print(f"‚úÖ Message authentique envoy√© (API directe) par {destination_entity.title}")
                                                else:
                                                    print(f"‚ö†Ô∏è Message envoy√© mais pas d'objet retourn√©")
                                                    
                                            except Exception as api_error:
                                                print(f"‚ö†Ô∏è √âchec API directe: {api_error}")
                                        
                                        # FALLBACK: Message normal si authentique √©choue
                                        if not authentic_success:
                                            sent_message = await client.send_message(
                                                destination_entity,
                                                processed_text,
                                                silent=False
                                            )
                                            print(f"‚úÖ Message normal envoy√© vers {destination_entity.title}")
                                    else:
                                        # Pas d'autorisation admin - envoyer normalement
                                        sent_message = await client.send_message(
                                            destination_entity,
                                            processed_text
                                        )
                                        print(f"‚úÖ Message envoy√© vers {destination_entity.title} (permissions limit√©es)")
                                    
                                    # Sauvegarder la correspondance pour futures √©ditions
                                    if source_key not in self.message_mapping:
                                        self.message_mapping[source_key] = {}
                                    self.message_mapping[source_key][str(dest_id)] = sent_message.id
                                    self.save_all_data()
                                    
                                except Exception as e:
                                    print(f"‚ùå Erreur envoi: {e}")
                                    try:
                                        # Fallback: envoyer avec ID direct
                                        sent_message = await client.send_message(dest_id, processed_text)
                                        
                                        if source_key not in self.message_mapping:
                                            self.message_mapping[source_key] = {}
                                        self.message_mapping[source_key][str(dest_id)] = sent_message.id
                                        self.save_all_data()
                                        
                                        print(f"‚úÖ Message envoy√© vers {dest_id} (fallback)")
                                    except Exception as e2:
                                        print(f"‚ùå Erreur fallback: {e2}")
                            
                        except Exception as e:
                            print(f"‚ùå Erreur redirection vers {dest_id}: {e}")
        
        async def new_message_handler(event):
            """Gestionnaire sp√©cifique pour nouveaux messages"""
            await message_handler(event, is_edit=False)
        
        async def edit_message_handler(event):
            """Gestionnaire sp√©cifique pour messages √©dit√©s"""
            await message_handler(event, is_edit=True)
        
        # Enregistrer les gestionnaires s√©par√©s sur ce client
        client.add_event_handler(new_message_handler, events.NewMessage)
        client.add_event_handler(edit_message_handler, events.MessageEdited)
        print(f"üì° Gestionnaire de redirection activ√© pour {phone_number} (messages + √©ditions)")
    
    async def connect_account(self, phone_number, api_id, api_hash):
        """Connecte un compte Telegram avec persistance automatique"""
        try:
            session_name = f"telefeed_{phone_number}"
            
            # V√©rifier si une session existe d√©j√† et est valide
            if phone_number in self.sessions and self.sessions[phone_number].get('connected'):
                if phone_number in self.clients:
                    # Session d√©j√† active
                    return {'status': 'already_connected', 'client': self.clients[phone_number]}
                
                # Tentative de restauration de session existante
                if os.path.exists(f"{session_name}.session"):
                    try:
                        client = TelegramClient(session_name, api_id, api_hash)
                        await client.connect()
                        
                        if await client.is_user_authorized():
                            self.clients[phone_number] = client
                            self.sessions[phone_number]['restored_at'] = datetime.now().isoformat()
                            self.save_all_data()
                            
                            # Enregistrer le gestionnaire de redirection sur ce client restaur√©
                            await self.setup_redirection_handlers(client, phone_number)
                            
                            print(f"‚úÖ Session restaur√©e automatiquement pour {phone_number}")
                            return {'status': 'restored', 'client': client}
                        else:
                            # Session expir√©e, continuer avec nouvelle connexion
                            pass
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erreur lors de la restauration pour {phone_number}: {e}")
            
            # Nouvelle connexion ou restauration √©chou√©e
            client = TelegramClient(session_name, api_id, api_hash)
            await client.connect()
            
            if not await client.is_user_authorized():
                # Demander le code d'authentification
                result = await client.send_code_request(phone_number)
                return {
                    'status': 'code_sent',
                    'phone_code_hash': result.phone_code_hash,
                    'client': client
                }
            else:
                # D√©j√† autoris√© (session valide)
                self.clients[phone_number] = client
                self.sessions[phone_number] = {
                    'connected': True,
                    'connected_at': datetime.now().isoformat(),
                    'session_file': f"{session_name}.session"
                }
                self.save_all_data()
                
                # Enregistrer le gestionnaire de redirection sur ce client
                await self.setup_redirection_handlers(client, phone_number)
                
                print(f"‚úÖ Connexion r√©ussie pour {phone_number}")
                return {'status': 'connected', 'client': client}
                
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    async def verify_code(self, phone_number, code, phone_code_hash, client):
        """V√©rifie le code d'authentification avec persistance"""
        try:
            await client.sign_in(phone_number, code, phone_code_hash=phone_code_hash)
            
            # Enregistrer le client et la session
            self.clients[phone_number] = client
            session_name = f"telefeed_{phone_number}"
            self.sessions[phone_number] = {
                'connected': True,
                'connected_at': datetime.now().isoformat(),
                'session_file': f"{session_name}.session",
                'verified_with_code': True
            }
            self.save_all_data()
            
            # Enregistrer le gestionnaire de redirection sur ce client
            await self.setup_redirection_handlers(client, phone_number)
            
            print(f"‚úÖ Session persistante cr√©√©e pour {phone_number}")
            return {'status': 'connected'}
            
        except SessionPasswordNeededError:
            return {'status': 'password_needed'}
        except PhoneCodeExpiredError:
            return {'status': 'code_expired'}
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    async def get_chats(self, phone_number):
        """R√©cup√®re la liste des chats"""
        if phone_number not in self.clients:
            return {'status': 'not_connected'}
            
        try:
            client = self.clients[phone_number]
            chats = []
            
            async for dialog in client.iter_dialogs(limit=100):
                chat_data = {
                    'id': dialog.id,
                    'title': dialog.title or dialog.name,
                    'type': 'unknown'
                }
                
                if isinstance(dialog.entity, User):
                    # D√©tecter si c'est un bot
                    if hasattr(dialog.entity, 'bot') and dialog.entity.bot:
                        chat_data['type'] = 'bot'
                    else:
                        chat_data['type'] = 'user'
                elif isinstance(dialog.entity, Chat):
                    chat_data['type'] = 'group'
                elif isinstance(dialog.entity, Channel):
                    chat_data['type'] = 'channel' if dialog.entity.broadcast else 'supergroup'
                
                chats.append(chat_data)
            
            # Sauvegarder les chats
            self.chats[phone_number] = chats
            self.save_all_data()
            
            return {'status': 'success', 'chats': chats}
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def add_redirection(self, phone_number, redirection_id, sources, destinations):
        """Ajoute une redirection"""
        try:
            if phone_number not in self.redirections:
                self.redirections[phone_number] = {}
            
            self.redirections[phone_number][redirection_id] = {
                'sources': sources,
                'destinations': destinations,
                'created_at': datetime.now().isoformat(),
                'active': True
            }
            
            # Param√®tres par d√©faut
            if phone_number not in self.settings:
                self.settings[phone_number] = {}
            
            self.settings[phone_number][redirection_id] = {
                'process_reply': True,
                'process_edit': True,
                'process_delete': True,
                'process_me': False,
                'process_forward': False,
                'process_raw': False,
                'process_duplicates': True,
                'delay_spread_mode': False
            }
            
            self.save_all_data()
            return True
            
        except Exception as e:
            print(f"Erreur lors de l'ajout de la redirection: {e}")
            return False
    
    def remove_redirection(self, phone_number, redirection_id):
        """Supprime une redirection"""
        try:
            if phone_number in self.redirections and redirection_id in self.redirections[phone_number]:
                del self.redirections[phone_number][redirection_id]
                
            if phone_number in self.settings and redirection_id in self.settings[phone_number]:
                del self.settings[phone_number][redirection_id]
                
            self.save_all_data()
            return True
        except:
            return False
    
    def apply_transformations(self, text, phone_number, redirection_id):
        """Applique les transformations sur le texte"""
        if not text:
            return text
            
        # Format transformation
        format_data = self.transformations.get(phone_number, {}).get(redirection_id, {}).get('format')
        if format_data:
            template = format_data.get('template', '[[Message.Text]]')
            text = template.replace('[[Message.Text]]', text)
        
        # Power transformation
        power_data = self.transformations.get(phone_number, {}).get(redirection_id, {}).get('power')
        if power_data:
            rules = power_data.get('rules', [])
            for rule in rules:
                if '=' in rule:
                    # Regex rule
                    pattern, replacement = rule.split('=', 1)
                    try:
                        text = re.sub(pattern, replacement, text, flags=re.MULTILINE | re.DOTALL)
                    except:
                        pass
                elif '","' in rule:
                    # Simple replacement
                    rule = rule.strip('"')
                    if '","' in rule:
                        old, new = rule.split('","', 1)
                        text = text.replace(old, new)
        
        # Remove lines transformation
        remove_lines_data = self.transformations.get(phone_number, {}).get(redirection_id, {}).get('removeLines')
        if remove_lines_data:
            keywords = remove_lines_data.get('keywords', [])
            lines = text.split('\n')
            filtered_lines = []
            
            for line in lines:
                should_remove = False
                for keyword in keywords:
                    if keyword in line:
                        should_remove = True
                        break
                if not should_remove:
                    filtered_lines.append(line)
            
            text = '\n'.join(filtered_lines)
        
        return text
    
    def should_process_message(self, text, phone_number, redirection_id):
        """V√©rifie si le message doit √™tre trait√© (whitelist/blacklist)"""
        # V√©rifier la blacklist
        blacklist_data = self.blacklist.get(phone_number, {}).get(redirection_id, {})
        if blacklist_data and blacklist_data.get('active', False):
            patterns = blacklist_data.get('patterns', [])
            for pattern in patterns:
                if isinstance(pattern, str):
                    if pattern.startswith('"') and pattern.endswith('"'):
                        # Simple text match
                        if pattern[1:-1] in text:
                            return False
                    else:
                        # Regex match
                        try:
                            if re.search(pattern, text, re.MULTILINE | re.DOTALL):
                                return False
                        except:
                            pass
        
        # V√©rifier la whitelist
        whitelist_data = self.whitelist.get(phone_number, {}).get(redirection_id, {})
        if whitelist_data and whitelist_data.get('active', False):
            patterns = whitelist_data.get('patterns', [])
            if patterns:
                for pattern in patterns:
                    if isinstance(pattern, str):
                        if pattern.startswith('"') and pattern.endswith('"'):
                            # Simple text match
                            if pattern[1:-1] in text:
                                return True
                        else:
                            # Regex match
                            try:
                                if re.search(pattern, text, re.MULTILINE | re.DOTALL):
                                    return True
                            except:
                                pass
                return False  # Whitelist active but no match
        
        return True
    
    def get_session_status(self, phone_number=None):
        """R√©cup√®re le statut des sessions"""
        if phone_number:
            # Statut d'une session sp√©cifique
            session_data = self.sessions.get(phone_number, {})
            is_connected = phone_number in self.clients
            return {
                'phone_number': phone_number,
                'connected': is_connected,
                'session_data': session_data,
                'has_client': is_connected
            }
        else:
            # Statut de toutes les sessions
            status = {
                'total_sessions': len(self.sessions),
                'active_clients': len(self.clients),
                'sessions': {}
            }
            
            for phone, session_data in self.sessions.items():
                is_connected = phone in self.clients
                status['sessions'][phone] = {
                    'connected': is_connected,
                    'session_data': session_data,
                    'has_client': is_connected
                }
            
            return status

# Instance globale
telefeed_manager = TeleFeedManager()

async def register_all_handlers(bot, ADMIN_ID, api_id, api_hash):
    """Enregistre tous les handlers TeleFeed et les redirections."""
    
    # Dictionnaire global pour stocker les connexions en attente
    pending_connections = {}
    
    @bot.on(events.NewMessage(pattern=r'/connect (\d+)'))
    async def connect_handler(event):
        """Handler pour connecter un compte TeleFeed"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        phone_number = event.pattern_match.group(1)
        user_id = event.sender_id
        
        await event.reply("üîå Connexion en cours...")
        
        try:
            result = await telefeed_manager.connect_account(phone_number, api_id, api_hash)
            
            if result['status'] == 'code_sent':
                # Stocker les donn√©es de connexion de mani√®re plus robuste
                pending_connections[user_id] = {
                    'phone_number': phone_number,
                    'phone_code_hash': result['phone_code_hash'],
                    'client': result['client'],
                    'timestamp': datetime.now().isoformat()
                }
                
                await event.reply(
                    f"üì± Code d'authentification envoy√© √† {phone_number}\n"
                    f"üí° R√©pondez avec: aa + votre code\n"
                    f"üìù Exemple: aa12345\n"
                    f"‚è∞ Code valide 5 minutes"
                )
                
            elif result['status'] == 'connected':
                await event.reply(f"‚úÖ Compte {phone_number} d√©j√† connect√©!")
                
            elif result['status'] == 'restored':
                await event.reply(f"‚úÖ Session {phone_number} restaur√©e automatiquement!")
                
            else:
                error_msg = result.get('message', 'Connexion √©chou√©e')
                if 'A wait of' in error_msg and 'seconds is required' in error_msg:
                    # Extraire le nombre de secondes
                    import re
                    seconds_match = re.search(r'A wait of (\d+) seconds', error_msg)
                    if seconds_match:
                        seconds = int(seconds_match.group(1))
                        hours = seconds // 3600
                        minutes = (seconds % 3600) // 60
                        
                        await event.reply(
                            f"‚è∞ **Limitation Telegram d√©tect√©e**\n\n"
                            f"Le num√©ro `{phone_number}` est temporairement bloqu√©.\n\n"
                            f"‚è±Ô∏è **Temps d'attente:** {hours}h {minutes}min\n\n"
                            f"üí° **Solutions:**\n"
                            f"‚Ä¢ Attendez la fin de la p√©riode\n"
                            f"‚Ä¢ Utilisez un autre num√©ro\n"
                            f"‚Ä¢ Essayez `/connect +33612345678`\n\n"
                            f"‚ùì Cette limitation vient de Telegram, pas du bot.",
                            parse_mode='markdown'
                        )
                    else:
                        await event.reply(f"‚ùå Erreur: {error_msg}")
                else:
                    await event.reply(f"‚ùå Erreur: {error_msg}")
                    
        except Exception as e:
            await event.reply(f"‚ùå Erreur lors de la connexion: {str(e)}")
    
    @bot.on(events.NewMessage(pattern=r'^aa(\d+)$'))
    async def verify_code_handler(event):
        """Handler pour v√©rifier le code d'authentification TeleFeed"""
        if not is_user_authorized(event.sender_id):
            return
        
        user_id = event.sender_id
        code = event.pattern_match.group(1)
        
        # V√©rifier s'il y a une connexion en attente pour cet utilisateur
        if user_id not in pending_connections:
            await event.reply("‚ùå Aucune connexion en attente. Utilisez d'abord /connect NUMERO")
            return
        
        connection_data = pending_connections[user_id]
        phone_number = connection_data['phone_number']
        
        await event.reply("üîê V√©rification du code...")
        
        try:
            result = await telefeed_manager.verify_code(
                phone_number, 
                code, 
                connection_data['phone_code_hash'], 
                connection_data['client']
            )
            
            if result['status'] == 'connected':
                await event.reply(
                    f"‚úÖ Compte {phone_number} connect√© avec succ√®s!\n"
                    f"üöÄ Utilisez /chats {phone_number} pour voir vos canaux\n"
                    f"üì° Utilisez /redirection pour configurer les redirections"
                )
                # Nettoyer la connexion en attente
                del pending_connections[user_id]
                
            elif result['status'] == 'password_needed':
                await event.reply(
                    "üîê Authentification 2FA requise.\n"
                    "Envoyez votre mot de passe d'application Telegram."
                )
                
            elif result['status'] == 'code_expired':
                await event.reply(
                    "‚è∞ Code expir√©.\n"
                    f"Utilisez √† nouveau /connect {phone_number} pour un nouveau code"
                )
                # Nettoyer la connexion expir√©e
                if user_id in pending_connections:
                    del pending_connections[user_id]
                    
            else:
                await event.reply(f"‚ùå Erreur: {result.get('message', 'Code invalide')}")
                
        except Exception as e:
            await event.reply(f"‚ùå Erreur lors de la v√©rification: {str(e)}")
            # Nettoyer en cas d'erreur
            if user_id in pending_connections:
                del pending_connections[user_id]
    
    @bot.on(events.NewMessage(pattern=r'/sessions'))
    async def sessions_status_handler(event):
        """Handler pour afficher le statut des sessions (admin seulement)"""
        if event.sender_id != ADMIN_ID:
            return
        
        status = telefeed_manager.get_session_status()
        
        message = "üìä **STATUT DES SESSIONS TELEFEED**\n\n"
        message += f"üìà **R√©sum√©:**\n"
        message += f"‚Ä¢ Sessions enregistr√©es: {status['total_sessions']}\n"
        message += f"‚Ä¢ Clients actifs: {status['active_clients']}\n\n"
        
        if status['sessions']:
            message += "üì± **D√©tails des sessions:**\n\n"
            for phone, session_info in status['sessions'].items():
                if phone.startswith('temp_'):
                    continue  # Ignorer les sessions temporaires
                    
                icon = "‚úÖ" if session_info['connected'] else "‚ùå"
                message += f"{icon} **{phone}**\n"
                
                session_data = session_info['session_data']
                if 'connected_at' in session_data:
                    message += f"   üìÖ Connect√©: {session_data['connected_at'][:16]}\n"
                if 'restored_at' in session_data:
                    message += f"   üîÑ Restaur√©: {session_data['restored_at'][:16]}\n"
                if 'session_file' in session_data:
                    message += f"   üíæ Fichier: {session_data['session_file']}\n"
                
                message += "\n"
        else:
            message += "üì≠ Aucune session enregistr√©e\n"
        
        message += "\nüí° **Utilisation:**\n"
        message += "‚Ä¢ Sessions persistantes = pas besoin de se reconnecter\n"
        message += "‚Ä¢ Utilisez `/connect NUMERO` pour ajouter un compte\n"
        message += "‚Ä¢ Les sessions sont automatiquement restaur√©es au red√©marrage"
        
        await event.reply(message, parse_mode='markdown')
    
    @bot.on(events.NewMessage(pattern=r'/permissions (-?\d+)'))
    async def check_permissions_handler(event):
        """Handler pour v√©rifier les permissions dans un canal (admin seulement)"""
        if event.sender_id != ADMIN_ID:
            return
        
        try:
            channel_id = int(event.pattern_match.group(1))
            
            # V√©rifier les permissions pour tous les comptes connect√©s
            report = "üîß **V√©rification des permissions**\n\n"
            
            for phone_number, client in telefeed_manager.clients.items():
                try:
                    # Obtenir l'entit√© du canal
                    channel = await client.get_entity(channel_id)
                    
                    # V√©rifier les permissions
                    permissions = await client.get_permissions(channel)
                    me = await client.get_me()
                    
                    report += f"üì± **{phone_number}** ({me.first_name})\n"
                    report += f"Canal : {channel.title}\n"
                    report += f"Type : {'Canal' if channel.broadcast else 'Groupe'}\n"
                    report += f"‚Ä¢ Publier messages : {'‚úÖ' if permissions.post_messages else '‚ùå'}\n"
                    report += f"‚Ä¢ Modifier messages : {'‚úÖ' if permissions.edit_messages else '‚ùå'}\n"
                    report += f"‚Ä¢ Supprimer messages : {'‚úÖ' if permissions.delete_messages else '‚ùå'}\n"
                    report += f"‚Ä¢ Admin : {'‚úÖ' if permissions.is_admin else '‚ùå'}\n\n"
                    
                except Exception as e:
                    report += f"üì± **{phone_number}** - ‚ùå Erreur : {e}\n\n"
            
            await event.reply(report, parse_mode='markdown')
            
        except ValueError:
            await event.reply("‚ùå ID de canal invalide")
        except Exception as e:
            await event.reply(f"‚ùå Erreur : {e}")
    
    @bot.on(events.NewMessage(pattern=r'/chats_old(?:\s+(.*))?'))
    async def chats_handler_old(event):
        """Handler pour lister les chats - Format identique aux captures d'√©cran"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        # Analyser les arguments
        args_text = event.pattern_match.group(1)
        
        if not args_text:
            # Afficher l'aide compl√®te exactement comme dans les captures
            help_text = (
                "**Chats Help Menu**\n"
                "Use it for getting all chats ID for use with other commands. You can use a filter to tell TeleFeed what type of chats to show.\n\n"
                "**Command Arguments**\n"
                "`/chats PHONE_NUMBER`\n"
                "`/chats FILTER PHONE_NUMBER`\n\n"
                "**Get all chats from 2759205517**\n"
                "`/chats 2759205517`\n\n"
                "**Get specific chats from 2759205517**\n"
                "`/chats user 2759205517`\n"
                "`/chats bot 2759205517`\n"
                "`/chats group 2759205517`\n"
                "`/chats channel 2759205517`"
            )
            await event.reply(help_text, parse_mode='markdown')
            return
        
        args = args_text.split()
        
        if len(args) == 1:
            # Format: /chats PHONE_NUMBER
            phone_number = args[0]
            chat_filter = None
        elif len(args) == 2:
            # Format: /chats FILTER PHONE_NUMBER
            chat_filter = args[0].lower()
            phone_number = args[1]
        else:
            await event.reply("‚ùå Format incorrect. Tapez `/chats` pour voir l'aide.")
            return
        
        await event.reply("**Getting Chats!**\nPlease wait...")
        
        result = await telefeed_manager.get_chats(phone_number)
        
        if result['status'] == 'success':
            chats = result['chats']
            if not chats:
                await event.reply("üì≠ Aucun chat trouv√©.")
                return
            
            # Appliquer le filtre si sp√©cifi√©
            if chat_filter:
                if chat_filter == 'user':
                    filtered_chats = [c for c in chats if c['type'] == 'user']
                elif chat_filter == 'bot':
                    filtered_chats = [c for c in chats if c['type'] == 'bot']
                elif chat_filter == 'group':
                    filtered_chats = [c for c in chats if c['type'] == 'group']
                elif chat_filter == 'channel':
                    filtered_chats = [c for c in chats if c['type'] == 'channel']
                else:
                    await event.reply("‚ùå Filtre invalide. Utilisez: user, bot, group, channel")
                    return
                chats = filtered_chats
            
            # Formater le message exactement comme dans les captures d'√©cran
            if chat_filter:
                if chat_filter == 'group':
                    header = "**Group Title | ID**\n\n"
                elif chat_filter == 'user':
                    header = "**User Title | ID**\n\n"
                elif chat_filter == 'bot':
                    header = "**Bot Title | ID**\n\n"
                elif chat_filter == 'channel':
                    header = "**Channel Title | ID**\n\n"
                else:
                    header = f"**{chat_filter.title()} Title | ID**\n\n"
            else:
                header = "**Group Title | ID**\n\n"
            
            message = header
            
            for chat in chats:
                title = chat['title'] if 'title' in chat else 'Sans titre'
                chat_id = chat['id'] if 'id' in chat else 'N/A'
                
                # Nettoyer le titre pour √©viter les probl√®mes de formatage
                if title:
                    title = str(title).replace('*', '').replace('_', '').replace('`', '')
                else:
                    title = 'Sans titre'
                
                # Format exact : Titre | ID (sans emoji, comme dans la capture)
                message += f"{title} | {chat_id}\n"
            
            # Diviser le message si trop long (plus de 4000 caract√®res)
            if len(message) > 4000:
                parts = []
                current_part = header
                
                for chat in chats:
                    title = chat['title'] if 'title' in chat else 'Sans titre'
                    if title:
                        title = str(title).replace('*', '').replace('_', '').replace('`', '')
                    else:
                        title = 'Sans titre'
                    chat_id = chat['id'] if 'id' in chat else 'N/A'
                    line = f"{title} | {chat_id}\n"
                    
                    if len(current_part + line) > 4000:
                        parts.append(current_part)
                        current_part = header + line
                    else:
                        current_part += line
                
                if current_part:
                    parts.append(current_part)
                
                for part in parts:
                    await event.reply(part, parse_mode='markdown')
            else:
                await event.reply(message, parse_mode='markdown')
            
        elif result['status'] == 'not_connected':
            await event.reply(f"‚ùå Compte {phone_number} non connect√©. Utilisez /connect {phone_number}")
            
        else:
            await event.reply(f"‚ùå Erreur: {result.get('message', 'Impossible de r√©cup√©rer les chats')}")
    
    @bot.on(events.NewMessage(pattern=r'/redirection add (\w+) on (\d+)'))
    async def add_redirection_handler(event):
        """Handler pour ajouter une redirection"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        redirection_id = event.pattern_match.group(1)
        phone_number = event.pattern_match.group(2)
        
        await event.reply(
            f"üîÑ Configuration de la redirection **{redirection_id}**\n\n"
            f"üìù Envoyez maintenant les IDs au format:\n"
            f"**SOURCE - DESTINATION**\n\n"
            f"üìã Exemples:\n"
            f"‚Ä¢ `123456789 - 987654321`\n"
            f"‚Ä¢ `123,456 - 789,012`\n"
            f"‚Ä¢ Utilisez /chats {phone_number} pour voir les IDs",
            parse_mode='markdown'
        )
        
        # Attendre la r√©ponse
        # Variables pour stocker la r√©ponse
        response_future = asyncio.Future()
        
        async def response_handler(response_event):
            if (response_event.sender_id == event.sender_id and 
                response_event.chat_id == event.chat_id and 
                ' - ' in response_event.raw_text):
                if not response_future.done():
                    response_future.set_result(response_event)
                    bot.remove_event_handler(response_handler)
        
        # Ajouter le gestionnaire temporaire
        bot.add_event_handler(response_handler, events.NewMessage)
        
        try:
            response = await asyncio.wait_for(response_future, timeout=60)
            
            # Parser la r√©ponse
            parts = response.raw_text.split(' - ')
            if len(parts) != 2:
                await event.reply("‚ùå Format invalide. Utilisez: SOURCE - DESTINATION")
                return
            
            sources = [int(x.strip()) for x in parts[0].split(',')]
            destinations = [int(x.strip()) for x in parts[1].split(',')]
            
            if telefeed_manager.add_redirection(phone_number, redirection_id, sources, destinations):
                await event.reply(f"‚úÖ Redirection **{redirection_id}** cr√©√©e avec succ√®s!")
            else:
                await event.reply("‚ùå Erreur lors de la cr√©ation de la redirection.")
                
        except asyncio.TimeoutError:
            await event.reply("‚è∞ Timeout. Recommencez la configuration.")
        except ValueError:
            await event.reply("‚ùå IDs invalides. Utilisez uniquement des nombres.")
    
    @bot.on(events.NewMessage(pattern=r'/redirection remove (\w+) on (\d+)'))
    async def remove_redirection_handler(event):
        """Handler pour supprimer une redirection"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        redirection_id = event.pattern_match.group(1)
        phone_number = event.pattern_match.group(2)
        
        if telefeed_manager.remove_redirection(phone_number, redirection_id):
            await event.reply(f"‚úÖ Redirection **{redirection_id}** supprim√©e.")
        else:
            await event.reply("‚ùå Redirection non trouv√©e.")
    
    @bot.on(events.NewMessage(pattern=r'/redirection (\d+)'))
    async def list_redirections_handler(event):
        """Handler pour lister les redirections"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        phone_number = event.pattern_match.group(1)
        
        redirections = telefeed_manager.redirections.get(phone_number, {})
        
        if not redirections:
            await event.reply(f"üì≠ Aucune redirection active pour {phone_number}")
            return
        
        message = f"üîÑ **Redirections actives pour {phone_number}:**\n\n"
        
        for redir_id, data in redirections.items():
            status = "‚úÖ" if data.get('active', True) else "‚ùå"
            sources = ', '.join(map(str, data.get('sources', [])))
            destinations = ', '.join(map(str, data.get('destinations', [])))
            
            message += f"{status} **{redir_id}**\n"
            message += f"üì§ Sources: `{sources}`\n"
            message += f"üì• Destinations: `{destinations}`\n\n"
        
        await event.reply(message, parse_mode='markdown')
    
    @bot.on(events.NewMessage(pattern=r'/transformation add (\w+) (\w+) on (\d+)'))
    async def add_transformation_handler(event):
        """Handler pour ajouter une transformation"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        feature = event.pattern_match.group(1)
        redirection_id = event.pattern_match.group(2)
        phone_number = event.pattern_match.group(3)
        
        if feature not in ['format', 'power', 'removeLines']:
            await event.reply("‚ùå Fonctionnalit√© non support√©e. Utilisez: format, power, removeLines")
            return
        
        await event.reply(
            f"‚öôÔ∏è Configuration de la transformation **{feature}** pour **{redirection_id}**\n\n"
            f"üìù Envoyez maintenant votre configuration:"
        )
        
        # Variables pour stocker la r√©ponse
        response_future = asyncio.Future()
        
        async def response_handler(response_event):
            if (response_event.sender_id == event.sender_id and 
                response_event.chat_id == event.chat_id):
                if not response_future.done():
                    response_future.set_result(response_event)
                    bot.remove_event_handler(response_handler)
        
        # Ajouter le gestionnaire temporaire
        bot.add_event_handler(response_handler, events.NewMessage)
        
        try:
            response = await asyncio.wait_for(response_future, timeout=120)
            
            # Initialiser la structure si n√©cessaire
            if phone_number not in telefeed_manager.transformations:
                telefeed_manager.transformations[phone_number] = {}
            if redirection_id not in telefeed_manager.transformations[phone_number]:
                telefeed_manager.transformations[phone_number][redirection_id] = {}
            
            # Configurer selon le type de transformation
            if feature == 'format':
                telefeed_manager.transformations[phone_number][redirection_id]['format'] = {
                    'template': response.raw_text,
                    'active': True
                }
            elif feature == 'power':
                rules = response.raw_text.split('\n')
                telefeed_manager.transformations[phone_number][redirection_id]['power'] = {
                    'rules': rules,
                    'active': True
                }
            elif feature == 'removeLines':
                keywords = [k.strip() for k in response.raw_text.split(',')]
                telefeed_manager.transformations[phone_number][redirection_id]['removeLines'] = {
                    'keywords': keywords,
                    'active': True
                }
            
            telefeed_manager.save_all_data()
            await event.reply(f"‚úÖ Transformation **{feature}** configur√©e pour **{redirection_id}**!")
            
        except asyncio.TimeoutError:
            await event.reply("‚è∞ Timeout. Recommencez la configuration.")
    
    @bot.on(events.NewMessage(pattern=r'/whitelist add (\w+) on (\d+)'))
    async def add_whitelist_handler(event):
        """Handler pour ajouter une whitelist"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        redirection_id = event.pattern_match.group(1)
        phone_number = event.pattern_match.group(2)
        
        await event.reply(
            f"‚ö™ Configuration de la whitelist pour **{redirection_id}**\n\n"
            f"üìù Envoyez les mots-cl√©s (un par ligne):"
        )
        
        # Variables pour stocker la r√©ponse
        response_future = asyncio.Future()
        
        async def response_handler(response_event):
            if (response_event.sender_id == event.sender_id and 
                response_event.chat_id == event.chat_id):
                if not response_future.done():
                    response_future.set_result(response_event)
                    bot.remove_event_handler(response_handler)
        
        # Ajouter le gestionnaire temporaire
        bot.add_event_handler(response_handler, events.NewMessage)
        
        try:
            response = await asyncio.wait_for(response_future, timeout=60)
            
            patterns = response.raw_text.split('\n')
            
            if phone_number not in telefeed_manager.whitelist:
                telefeed_manager.whitelist[phone_number] = {}
            
            telefeed_manager.whitelist[phone_number][redirection_id] = {
                'patterns': patterns,
                'active': True
            }
            
            telefeed_manager.save_all_data()
            await event.reply(f"‚úÖ Whitelist configur√©e pour **{redirection_id}**!")
            
        except asyncio.TimeoutError:
            await event.reply("‚è∞ Timeout. Recommencez la configuration.")
    
    @bot.on(events.NewMessage(pattern=r'/blacklist add (\w+) on (\d+)'))
    async def add_blacklist_handler(event):
        """Handler pour ajouter une blacklist"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        redirection_id = event.pattern_match.group(1)
        phone_number = event.pattern_match.group(2)
        
        await event.reply(
            f"‚ö´ Configuration de la blacklist pour **{redirection_id}**\n\n"
            f"üìù Envoyez les mots-cl√©s √† bloquer (un par ligne):"
        )
        
        # Variables pour stocker la r√©ponse
        response_future = asyncio.Future()
        
        async def response_handler(response_event):
            if (response_event.sender_id == event.sender_id and 
                response_event.chat_id == event.chat_id):
                if not response_future.done():
                    response_future.set_result(response_event)
                    bot.remove_event_handler(response_handler)
        
        # Ajouter le gestionnaire temporaire
        bot.add_event_handler(response_handler, events.NewMessage)
        
        try:
            response = await asyncio.wait_for(response_future, timeout=60)
            
            patterns = response.raw_text.split('\n')
            
            if phone_number not in telefeed_manager.blacklist:
                telefeed_manager.blacklist[phone_number] = {}
            
            telefeed_manager.blacklist[phone_number][redirection_id] = {
                'patterns': patterns,
                'active': True
            }
            
            telefeed_manager.save_all_data()
            await event.reply(f"‚úÖ Blacklist configur√©e pour **{redirection_id}**!")
            
        except asyncio.TimeoutError:
            await event.reply("‚è∞ Timeout. Recommencez la configuration.")
    
    @bot.on(events.NewMessage(pattern=r'/telefeed'))
    async def telefeed_help_handler(event):
        """Handler pour l'aide TeleFeed"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        help_message = """
üöÄ **TeleFeed - Guide des commandes**

**üì± Connexion:**
‚Ä¢ `/connect <num√©ro>` - Connecter un compte
‚Ä¢ `/chats <num√©ro>` - Voir les chats disponibles

**üîÑ Redirections:**
‚Ä¢ `/redirection add <nom> on <num√©ro>` - Ajouter
‚Ä¢ `/redirection remove <nom> on <num√©ro>` - Supprimer
‚Ä¢ `/redirection <num√©ro>` - Lister les redirections

**‚öôÔ∏è Transformations:**
‚Ä¢ `/transformation add <type> <nom> on <num√©ro>`
‚Ä¢ Types: format, power, removeLines

**üîç Filtres:**
‚Ä¢ `/whitelist add <nom> on <num√©ro>` - Mots autoris√©s
‚Ä¢ `/blacklist add <nom> on <num√©ro>` - Mots bloqu√©s

**üí° Exemple complet:**
1. `/connect 33123456789`
2. `aa12345` (apr√®s r√©ception du code)
3. `/chats 33123456789`
4. `/redirection add test on 33123456789`
5. `123456789 - 987654321`

**üìû Support:** @SossouKouame
        """
        
        await event.reply(help_message, parse_mode='markdown')
    
    # Handler pour les messages redirig√©s
    async def handle_message_redirection(event):
        """Gestionnaire principal pour les redirections de messages"""
        # V√©rifier tous les comptes connect√©s
        for phone_number, client in telefeed_manager.clients.items():
            if client == event.client:
                # V√©rifier les redirections pour ce num√©ro
                redirections = telefeed_manager.redirections.get(phone_number, {})
                
                for redir_id, redir_data in redirections.items():
                    if not redir_data.get('active', True):
                        continue
                    
                    # V√©rifier si ce chat est dans les sources
                    if event.chat_id in redir_data.get('sources', []):
                        text = event.raw_text or ''
                        
                        # V√©rifier les filtres
                        if not telefeed_manager.should_process_message(text, phone_number, redir_id):
                            continue
                        
                        # Appliquer les transformations
                        processed_text = telefeed_manager.apply_transformations(text, phone_number, redir_id)
                        
                        # Envoyer vers les destinations
                        for dest_id in redir_data.get('destinations', []):
                            try:
                                await client.send_message(dest_id, processed_text)
                            except Exception as e:
                                print(f"Erreur lors de l'envoi vers {dest_id}: {e}")
    
    # Enregistrer le handler pour tous les messages
    @bot.on(events.NewMessage)
    async def handle_message_edited(event):
        """Gestionnaire des messages √©dit√©s sans indication"""
        await handle_message_redirection(event)
    
    # Commande /export - Envoie tous les fichiers du projet (admin)
    @bot.on(events.NewMessage(pattern='/export'))
    async def export_command(event):
        user_id = str(event.sender_id)
        if user_id not in ADMIN_IDS:
            await event.respond("‚ùå Acc√®s refus√©")
            return
        
        await event.respond("üì¶ Pr√©paration de l'export de tous les fichiers...")
        
        import os
        import zipfile
        import tempfile
        
        try:
            # Cr√©er un fichier zip temporaire
            with tempfile.NamedTemporaryFile(suffix='.zip', delete=False) as tmp_zip:
                zip_path = tmp_zip.name
            
            # Cr√©er l'archive avec tous les fichiers
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Parcourir tous les fichiers du projet
                for root, dirs, files in os.walk('.'):
                    # Ignorer certains dossiers
                    dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', '.pythonlibs', 'node_modules']]
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        # Ignorer les fichiers syst√®me
                        if not file.startswith('.') and not file.endswith('.pyc'):
                            # Cr√©er l'info du fichier avec un timestamp valide
                            info = zipfile.ZipInfo(file_path)
                            info.date_time = (1980, 1, 1, 0, 0, 0)  # Timestamp minimal valide
                            
                            # Lire le contenu du fichier
                            with open(file_path, 'rb') as f:
                                content = f.read()
                            
                            # Ajouter au zip
                            zipf.writestr(info, content)
            
            # Envoyer l'archive
            await event.respond(
                "üìÅ **Export du projet TeleFoot Bot**\n\n"
                "üì¶ Archive compl√®te avec tous les fichiers sources",
                file=zip_path
            )
            
            # Nettoyer le fichier temporaire
            os.unlink(zip_path)
            
        except Exception as e:
            await event.respond(f"‚ùå Erreur lors de l'export: {str(e)}")
            print(f"Erreur export: {e}")

    # Commande /files - Liste tous les fichiers du projet (admin)
    @bot.on(events.NewMessage(pattern='/files'))
    async def files_command(event):
        user_id = str(event.sender_id)
        if user_id not in ADMIN_IDS:
            await event.respond("‚ùå Acc√®s refus√©")
            return
        
        import os
        
        files_list = []
        total_size = 0
        
        for root, dirs, files in os.walk('.'):
            # Ignorer certains dossiers
            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', '.pythonlibs', 'node_modules']]
            
            for file in files:
                if not file.startswith('.') and not file.endswith('.pyc'):
                    file_path = os.path.join(root, file)
                    try:
                        size = os.path.getsize(file_path)
                        total_size += size
                        size_str = f"{size:,} bytes" if size < 1024 else f"{size//1024:,} KB"
                        files_list.append(f"üìÑ {file_path} ({size_str})")
                    except:
                        files_list.append(f"üìÑ {file_path}")
        
        # Diviser en messages si trop long
        message = f"üìÅ **Fichiers du projet TeleFoot Bot:**\n\n"
        message += f"üìä Total: {len(files_list)} fichiers ({total_size//1024:,} KB)\n\n"
        
        current_message = message
        for file_info in files_list:
            if len(current_message + file_info + "\n") > 4000:
                await event.respond(current_message)
                current_message = file_info + "\n"
            else:
                current_message += file_info + "\n"
        
        if current_message.strip():
            await event.respond(current_message)

    # Commande /backup - Sauvegarde de tous les fichiers de configuration (admin)
    @bot.on(events.NewMessage(pattern='/backup'))
    async def backup_command(event):
        user_id = str(event.sender_id)
        if user_id not in ADMIN_IDS:
            await event.respond("‚ùå Acc√®s refus√©")
            return
        
        await event.respond("üíæ Cr√©ation de la sauvegarde...")
        
        import os
        import zipfile
        import tempfile
        from datetime import datetime
        
        try:
            # Cr√©er un nom de fichier avec la date
            now = datetime.now()
            backup_name = f"telefoot_backup_{now.strftime('%Y%m%d_%H%M%S')}.zip"
            
            # Cr√©er un fichier zip temporaire
            with tempfile.NamedTemporaryFile(suffix='.zip', delete=False) as tmp_zip:
                zip_path = tmp_zip.name
            
            # Fichiers de configuration importants
            config_files = [
                'telefeed_redirections.json',
                'telefeed_transformations.json',
                'telefeed_filters.json',
                'telefeed_whitelist.json',
                'telefeed_blacklist.json',
                'telefeed_settings.json',
                'telefeed_sessions.json',
                'telefeed_chats.json',
                'telefeed_delay.json',
                'telefeed_message_mapping.json',
                'users.json',
                'redirections.json',
                'filters.json',
                'format.json',
                'delay.json',
                'pending_redirections.json',
                'config.py',
                'main.py',
                'telefeed_commands.py'
            ]
            
            # Cr√©er l'archive avec les fichiers de configuration
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for file in config_files:
                    if os.path.exists(file):
                        zipf.write(file, file)
            
            # Envoyer l'archive
            await event.respond(
                f"üíæ **Sauvegarde TeleFoot Bot**\n\n"
                f"üìÖ Date: {now.strftime('%d/%m/%Y %H:%M:%S')}\n"
                f"üì¶ Fichiers de configuration sauvegard√©s",
                file=zip_path,
                attributes=[
                    ('DocumentAttributeFilename', {'file_name': backup_name})
                ]
            )
            
            # Nettoyer le fichier temporaire
            os.unlink(zip_path)
            
        except Exception as e:
            await event.respond(f"‚ùå Erreur lors de la sauvegarde: {str(e)}")
            print(f"Erreur backup: {e}")

    # Commande /redirection
    @bot.on(events.NewMessage(pattern=r'/redirection (.*)'))
    async def redirection_handler(event):
        """Handler pour la commande /redirection"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        command_args = event.pattern_match.group(1).strip()
        parts = command_args.split()
        
        if len(parts) == 1:
            # /redirection PHONE - Afficher les redirections actives
            phone = parts[0]
            redirections = telefeed_manager.redirections.get(phone, {})
            
            if not redirections:
                await event.reply(f"üì≠ Aucune redirection active pour {phone}")
                return
            
            message = f"üì° **Redirections actives pour {phone}:**\n\n"
            for redir_id, redir_data in redirections.items():
                status = "‚úÖ" if redir_data.get('active', True) else "‚ùå"
                sources = redir_data.get('sources', [])
                destinations = redir_data.get('destinations', [])
                message += f"{status} **{redir_id}**\n"
                message += f"   üì• Sources: {', '.join(map(str, sources))}\n"
                message += f"   üì§ Destinations: {', '.join(map(str, destinations))}\n\n"
            
            await event.reply(message, parse_mode='markdown')
            
        elif len(parts) >= 3 and parts[0] in ['add', 'remove', 'change']:
            action = parts[0]
            
            # Chercher le mot "on" dans la commande
            on_index = -1
            for i, part in enumerate(parts):
                if part == 'on':
                    on_index = i
                    break
            
            if on_index > 0 and on_index < len(parts) - 1:
                redirection_id = ' '.join(parts[1:on_index])
                phone = ' '.join(parts[on_index + 1:])
                
                if action == 'add':
                    await event.reply(
                        f"üì° Configuration de la redirection **{redirection_id}** pour {phone}\n\n"
                        f"Envoyez les IDs de chat selon la syntaxe:\n"
                        f"**SOURCE - DESTINATION**\n\n"
                        f"Exemples:\n"
                        f"‚Ä¢ `708415014 - 642797040`\n"
                        f"‚Ä¢ `53469647,708415014 - 20801978` (multi-sources)\n"
                        f"‚Ä¢ `20801978 - 53469647,708415014` (multi-destinations)",
                        parse_mode='markdown'
                    )
                    # Stocker l'√©tat en attente
                    telefeed_manager.sessions[f"pending_redirection_{event.sender_id}"] = {
                        'action': action,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
                    
                elif action == 'remove':
                    success = telefeed_manager.remove_redirection(phone, redirection_id)
                    if success:
                        await event.reply(f"‚úÖ Redirection {redirection_id} supprim√©e pour {phone}")
                    else:
                        await event.reply(f"‚ùå Redirection {redirection_id} introuvable pour {phone}")
                        
                elif action == 'change':
                    await event.reply(
                        f"üîß Modification de la redirection **{redirection_id}** pour {phone}\n\n"
                        f"Envoyez les nouveaux IDs selon la syntaxe:\n"
                        f"**SOURCE - DESTINATION**",
                        parse_mode='markdown'
                    )
                    # Stocker l'√©tat en attente
                    telefeed_manager.sessions[f"pending_redirection_{event.sender_id}"] = {
                        'action': action,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
            else:
                await event.reply("‚ùå Syntaxe incorrecte. Utilisez: /redirection action redirectionid on phonenumber")
        else:
            await event.reply("‚ùå Syntaxe incorrecte. Utilisez: /redirection PHONE ou /redirection action redirectionid on phonenumber")
    
    # Handler pour traiter les r√©ponses aux commandes en attente
    @bot.on(events.NewMessage())
    async def pending_commands_handler(event):
        """Handler pour traiter les commandes en attente"""
        if not is_user_authorized(event.sender_id):
            return
        
        user_id = event.sender_id
        text = event.raw_text
        
        # Ignorer les commandes qui commencent par /
        if text.startswith('/'):
            return
        
        # V√©rifier s'il y a une commande redirection en attente
        pending_key = f"pending_redirection_{user_id}"
        if pending_key in telefeed_manager.sessions:
            pending_data = telefeed_manager.sessions[pending_key]
            
            # Traiter la syntaxe SOURCE - DESTINATION
            if ' - ' in text:
                try:
                    sources_str, destinations_str = text.split(' - ', 1)
                    
                    # Parser les sources
                    sources = []
                    for source in sources_str.split(','):
                        source = source.strip()
                        if source.isdigit():
                            sources.append(int(source))
                    
                    # Parser les destinations
                    destinations = []
                    for dest in destinations_str.split(','):
                        dest = dest.strip()
                        if dest.isdigit():
                            destinations.append(int(dest))
                    
                    if sources and destinations:
                        # Ajouter la redirection
                        success = telefeed_manager.add_redirection(
                            pending_data['phone'],
                            pending_data['redirection_id'],
                            sources,
                            destinations
                        )
                        
                        if success:
                            await event.reply(
                                f"‚úÖ Redirection **{pending_data['redirection_id']}** configur√©e!\n\n"
                                f"üì• Sources: {', '.join(map(str, sources))}\n"
                                f"üì§ Destinations: {', '.join(map(str, destinations))}\n\n"
                                f"üöÄ La redirection est maintenant active!",
                                parse_mode='markdown'
                            )
                        else:
                            await event.reply("‚ùå Erreur lors de la configuration de la redirection")
                        
                        # Nettoyer l'√©tat en attente
                        del telefeed_manager.sessions[pending_key]
                    else:
                        await event.reply("‚ùå IDs invalides. Utilisez uniquement des nombres.")
                        
                except Exception as e:
                    await event.reply(f"‚ùå Erreur de syntaxe: {str(e)}")
            else:
                # Commande non li√©e √† la redirection, ignorer
                pass
        
        # V√©rifier s'il y a une commande transformation en attente
        pending_key = f"pending_transformation_{user_id}"
        if pending_key in telefeed_manager.sessions:
            pending_data = telefeed_manager.sessions[pending_key]
            feature = pending_data['feature']
            
            # Traiter selon le type de transformation
            try:
                if feature == 'format':
                    # Stocker le format
                    if pending_data['phone'] not in telefeed_manager.transformations:
                        telefeed_manager.transformations[pending_data['phone']] = {}
                    if pending_data['redirection_id'] not in telefeed_manager.transformations[pending_data['phone']]:
                        telefeed_manager.transformations[pending_data['phone']][pending_data['redirection_id']] = {}
                    
                    telefeed_manager.transformations[pending_data['phone']][pending_data['redirection_id']]['format'] = {
                        'template': text
                    }
                    telefeed_manager.save_all_data()
                    
                    await event.reply(
                        f"‚úÖ Format configur√© pour **{pending_data['redirection_id']}**\n\n"
                        f"üìù Template: `{text[:100]}{'...' if len(text) > 100 else ''}`",
                        parse_mode='markdown'
                    )
                    
                elif feature == 'removeLines':
                    # Stocker les mots-cl√©s √† supprimer
                    keywords = [line.strip() for line in text.split('\n') if line.strip()]
                    
                    if pending_data['phone'] not in telefeed_manager.transformations:
                        telefeed_manager.transformations[pending_data['phone']] = {}
                    if pending_data['redirection_id'] not in telefeed_manager.transformations[pending_data['phone']]:
                        telefeed_manager.transformations[pending_data['phone']][pending_data['redirection_id']] = {}
                    
                    telefeed_manager.transformations[pending_data['phone']][pending_data['redirection_id']]['removeLines'] = {
                        'keywords': keywords
                    }
                    telefeed_manager.save_all_data()
                    
                    await event.reply(
                        f"‚úÖ RemoveLines configur√© pour **{pending_data['redirection_id']}**\n\n"
                        f"üîç Mots-cl√©s: {', '.join(keywords[:5])}{'...' if len(keywords) > 5 else ''}",
                        parse_mode='markdown'
                    )
                    
                elif feature == 'power':
                    # Stocker les r√®gles de remplacement
                    rules = [line.strip() for line in text.split('\n') if line.strip()]
                    
                    if pending_data['phone'] not in telefeed_manager.transformations:
                        telefeed_manager.transformations[pending_data['phone']] = {}
                    if pending_data['redirection_id'] not in telefeed_manager.transformations[pending_data['phone']]:
                        telefeed_manager.transformations[pending_data['phone']][pending_data['redirection_id']] = {}
                    
                    telefeed_manager.transformations[pending_data['phone']][pending_data['redirection_id']]['power'] = {
                        'rules': rules
                    }
                    telefeed_manager.save_all_data()
                    
                    await event.reply(
                        f"‚úÖ Power configur√© pour **{pending_data['redirection_id']}**\n\n"
                        f"‚ö° R√®gles: {len(rules)} configur√©es",
                        parse_mode='markdown'
                    )
                
                # Nettoyer l'√©tat en attente
                del telefeed_manager.sessions[pending_key]
                
            except Exception as e:
                await event.reply(f"‚ùå Erreur lors de la configuration: {str(e)}")
        
        # V√©rifier s'il y a une commande whitelist en attente
        pending_key = f"pending_whitelist_{user_id}"
        if pending_key in telefeed_manager.sessions:
            pending_data = telefeed_manager.sessions[pending_key]
            
            try:
                rules = [line.strip() for line in text.split('\n') if line.strip()]
                
                if pending_data['phone'] not in telefeed_manager.whitelist:
                    telefeed_manager.whitelist[pending_data['phone']] = {}
                
                telefeed_manager.whitelist[pending_data['phone']][pending_data['redirection_id']] = rules
                telefeed_manager.save_all_data()
                
                await event.reply(
                    f"‚úÖ Whitelist configur√©e pour **{pending_data['redirection_id']}**\n\n"
                    f"üìã R√®gles: {len(rules)} configur√©es",
                    parse_mode='markdown'
                )
                
                # Nettoyer l'√©tat en attente
                del telefeed_manager.sessions[pending_key]
                
            except Exception as e:
                await event.reply(f"‚ùå Erreur lors de la configuration: {str(e)}")
        
        # V√©rifier s'il y a une redirection GUI en attente
        pending_key = f"gui_redirection_{user_id}"
        if pending_key in telefeed_manager.sessions:
            pending_data = telefeed_manager.sessions[pending_key]
            
            try:
                if 'redirection_name' not in pending_data:
                    # Premi√®re √©tape : nom de la redirection
                    pending_data['redirection_name'] = text.strip()
                    telefeed_manager.sessions[pending_key] = pending_data
                    
                    await event.reply(
                        f"‚úÖ Nom de redirection: **{text.strip()}**\n\n"
                        f"**√âtape 2:** Envoyez maintenant la configuration:\n"
                        f"`SOURCE - DESTINATION`\n\n"
                        f"**Exemples:**\n"
                        f"‚Ä¢ `708415014 - 642797040`\n"
                        f"‚Ä¢ `53469647,708415014 - 20801978`",
                        parse_mode='markdown'
                    )
                elif ' - ' in text:
                    # Deuxi√®me √©tape : configuration source-destination
                    sources_str, destinations_str = text.split(' - ', 1)
                    
                    sources = []
                    for source in sources_str.split(','):
                        source = source.strip()
                        if source.isdigit():
                            sources.append(int(source))
                    
                    destinations = []
                    for dest in destinations_str.split(','):
                        dest = dest.strip()
                        if dest.isdigit():
                            destinations.append(int(dest))
                    
                    if sources and destinations:
                        success = telefeed_manager.add_redirection(
                            pending_data['phone'],
                            pending_data['redirection_name'],
                            sources,
                            destinations
                        )
                        
                        if success:
                            await event.reply(
                                f"‚úÖ Redirection **{pending_data['redirection_name']}** cr√©√©e!\n\n"
                                f"üì• Sources: {', '.join(map(str, sources))}\n"
                                f"üì§ Destinations: {', '.join(map(str, destinations))}\n\n"
                                f"üöÄ La redirection est maintenant active!",
                                parse_mode='markdown'
                            )
                        else:
                            await event.reply("‚ùå Erreur lors de la cr√©ation de la redirection")
                        
                        # Nettoyer l'√©tat
                        del telefeed_manager.sessions[pending_key]
                    else:
                        await event.reply("‚ùå IDs invalides. Utilisez uniquement des nombres.")
                        
            except Exception as e:
                await event.reply(f"‚ùå Erreur: {str(e)}")
                # Nettoyer en cas d'erreur
                if pending_key in telefeed_manager.sessions:
                    del telefeed_manager.sessions[pending_key]
        
        # V√©rifier s'il y a une commande blacklist en attente
        pending_key = f"pending_blacklist_{user_id}"
        if pending_key in telefeed_manager.sessions:
            pending_data = telefeed_manager.sessions[pending_key]
            
            try:
                rules = [line.strip() for line in text.split('\n') if line.strip()]
                
                if pending_data['phone'] not in telefeed_manager.blacklist:
                    telefeed_manager.blacklist[pending_data['phone']] = {}
                
                telefeed_manager.blacklist[pending_data['phone']][pending_data['redirection_id']] = rules
                telefeed_manager.save_all_data()
                
                await event.reply(
                    f"‚úÖ Blacklist configur√©e pour **{pending_data['redirection_id']}**\n\n"
                    f"üìã R√®gles: {len(rules)} configur√©es",
                    parse_mode='markdown'
                )
                
                # Nettoyer l'√©tat en attente
                del telefeed_manager.sessions[pending_key]
                
            except Exception as e:
                await event.reply(f"‚ùå Erreur lors de la configuration: {str(e)}")
    
    # Commande /chats
    @bot.on(events.NewMessage(pattern=r'/chats (\d+)'))
    async def chats_handler(event):
        """Handler pour afficher les chats d'un num√©ro"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        phone_number = event.pattern_match.group(1)
        
        if phone_number not in telefeed_manager.clients:
            await event.reply(f"‚ùå Compte {phone_number} non connect√©. Utilisez /connect {phone_number}")
            return
        
        await event.reply("üìã R√©cup√©ration des chats...")
        
        result = await telefeed_manager.get_chats(phone_number)
        
        if result['status'] == 'success':
            chats = result['chats']
            
            if not chats:
                await event.reply("üì≠ Aucun chat trouv√©.")
                return
            
            # Grouper par type
            channels = [c for c in chats if c['type'] == 'channel']
            supergroups = [c for c in chats if c['type'] == 'supergroup']
            groups = [c for c in chats if c['type'] == 'group']
            users = [c for c in chats if c['type'] in ['user', 'bot']]
            
            message = f"üìã **Chats pour {phone_number}**\n\n"
            
            if channels:
                message += "üì∫ **Canaux:**\n"
                for chat in channels[:10]:  # Limiter √† 10
                    message += f"   ‚Ä¢ {chat['title']} (`{chat['id']}`)\n"
                if len(channels) > 10:
                    message += f"   ... et {len(channels) - 10} autres\n"
                message += "\n"
            
            if supergroups:
                message += "üë• **Supergroupes:**\n"
                for chat in supergroups[:10]:
                    message += f"   ‚Ä¢ {chat['title']} (`{chat['id']}`)\n"
                if len(supergroups) > 10:
                    message += f"   ... et {len(supergroups) - 10} autres\n"
                message += "\n"
            
            if groups:
                message += "üè† **Groupes:**\n"
                for chat in groups[:10]:
                    message += f"   ‚Ä¢ {chat['title']} (`{chat['id']}`)\n"
                if len(groups) > 10:
                    message += f"   ... et {len(groups) - 10} autres\n"
                message += "\n"
            
            message += f"üí° **Total:** {len(chats)} chats\n"
            message += f"üìù Utilisez les IDs entre parenth√®ses pour /redirection"
            
            await event.reply(message, parse_mode='markdown')
            
        else:
            await event.reply(f"‚ùå Erreur: {result.get('message', 'Impossible de r√©cup√©rer les chats')}")
    
    # Commande /transformation
    @bot.on(events.NewMessage(pattern=r'/transformation (.*)'))
    async def transformation_handler(event):
        """Handler pour la commande /transformation"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        command_args = event.pattern_match.group(1).strip()
        parts = command_args.split()
        
        if len(parts) >= 3 and parts[0] in ['add', 'remove']:
            action = parts[0]
            feature = parts[1]  # format, power, removeLines
            
            if feature not in ['format', 'power', 'removeLines']:
                await event.reply("‚ùå Features support√©es: format, power, removeLines")
                return
            
            # Trouver le redirection_id et phone
            remaining = ' '.join(parts[2:])
            if ' on ' in remaining:
                redirection_id, phone = remaining.split(' on ', 1)
                redirection_id = redirection_id.strip()
                phone = phone.strip()
                
                if action == 'add':
                    if feature == 'format':
                        help_text = "üìù Envoyez le format avec [[Message.Text]] pour le texte"
                    elif feature == 'removeLines':
                        help_text = "üîç Envoyez les mots-cl√©s √† supprimer (un par ligne)"
                    elif feature == 'power':
                        help_text = "‚ö° Envoyez les r√®gles de remplacement: \"ancien\",\"nouveau\""
                    else:
                        help_text = ""
                    
                    await event.reply(
                        f"üîß Configuration transformation **{feature}** pour {redirection_id}\n\n{help_text}",
                        parse_mode='markdown'
                    )
                    # Stocker l'√©tat en attente
                    telefeed_manager.sessions[f"pending_transformation_{event.sender_id}"] = {
                        'action': action,
                        'feature': feature,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
                    
                elif action == 'remove':
                    # Supprimer la transformation
                    if phone in telefeed_manager.transformations:
                        if redirection_id in telefeed_manager.transformations[phone]:
                            if feature in telefeed_manager.transformations[phone][redirection_id]:
                                del telefeed_manager.transformations[phone][redirection_id][feature]
                                telefeed_manager.save_all_data()
                                await event.reply(f"‚úÖ Transformation {feature} supprim√©e pour {redirection_id}")
                            else:
                                await event.reply(f"‚ùå Transformation {feature} introuvable pour {redirection_id}")
                        else:
                            await event.reply(f"‚ùå Redirection {redirection_id} introuvable")
                    else:
                        await event.reply(f"‚ùå Aucune transformation pour {phone}")
            else:
                await event.reply("‚ùå Syntaxe incorrecte. Utilisez: /transformation action feature redirectionid on phonenumber")
                
        elif len(parts) >= 2 and parts[0] == 'active':
            if ' on ' in command_args:
                # /transformation active redirectionid on phone
                remaining = command_args.replace('active ', '', 1)
                redirection_id, phone = remaining.split(' on ', 1)
                redirection_id = redirection_id.strip()
                phone = phone.strip()
                
                transformations = telefeed_manager.transformations.get(phone, {}).get(redirection_id, {})
                
                message = f"üîß **Transformations actives pour {redirection_id}:**\n\n"
                if not transformations:
                    message += "üì≠ Aucune transformation active"
                else:
                    for feature, config in transformations.items():
                        message += f"‚úÖ **{feature}**\n"
                        if isinstance(config, dict) and 'rules' in config:
                            message += f"   R√®gles: {len(config['rules'])}\n"
                        message += "\n"
                
                await event.reply(message, parse_mode='markdown')
            else:
                # /transformation active on phone - toutes les transformations
                phone = parts[-1]
                all_transformations = telefeed_manager.transformations.get(phone, {})
                
                message = f"üîß **Toutes les transformations pour {phone}:**\n\n"
                if not all_transformations:
                    message += "üì≠ Aucune transformation active"
                else:
                    for redir_id, transforms in all_transformations.items():
                        message += f"üì° **{redir_id}:**\n"
                        for feature in transforms.keys():
                            message += f"   ‚úÖ {feature}\n"
                        message += "\n"
                
                await event.reply(message, parse_mode='markdown')
                
        elif len(parts) >= 2 and parts[0] == 'clear':
            if ' on ' in command_args:
                # /transformation clear redirectionid on phone
                remaining = command_args.replace('clear ', '', 1)
                redirection_id, phone = remaining.split(' on ', 1)
                redirection_id = redirection_id.strip()
                phone = phone.strip()
                
                if phone in telefeed_manager.transformations:
                    if redirection_id in telefeed_manager.transformations[phone]:
                        del telefeed_manager.transformations[phone][redirection_id]
                        telefeed_manager.save_all_data()
                        await event.reply(f"‚úÖ Toutes les transformations supprim√©es pour {redirection_id}")
                    else:
                        await event.reply(f"‚ùå Redirection {redirection_id} introuvable")
                else:
                    await event.reply(f"‚ùå Aucune transformation pour {phone}")
            else:
                # /transformation clear on phone - tout supprimer
                phone = parts[-1]
                if phone in telefeed_manager.transformations:
                    del telefeed_manager.transformations[phone]
                    telefeed_manager.save_all_data()
                    await event.reply(f"‚úÖ Toutes les transformations supprim√©es pour {phone}")
                else:
                    await event.reply(f"‚ùå Aucune transformation pour {phone}")
        else:
            await event.reply("‚ùå Syntaxe incorrecte. Consultez /help pour les exemples")
    
    # Commande /whitelist
    @bot.on(events.NewMessage(pattern=r'/whitelist (.*)'))
    async def whitelist_handler(event):
        """Handler pour la commande /whitelist"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        command_args = event.pattern_match.group(1).strip()
        parts = command_args.split()
        
        if len(parts) >= 2 and parts[0] in ['add', 'remove', 'change']:
            action = parts[0]
            
            if ' on ' in command_args:
                remaining = command_args.replace(f'{action} ', '', 1)
                redirection_id, phone = remaining.split(' on ', 1)
                redirection_id = redirection_id.strip()
                phone = phone.strip()
                
                if action == 'add':
                    await event.reply(
                        f"‚úÖ Configuration whitelist pour **{redirection_id}**\n\n"
                        f"Envoyez les mots/phrases √† autoriser (un par ligne):\n\n"
                        f"**Syntaxe Simple:**\n"
                        f"‚Ä¢ `\"bitcoin\"`\n"
                        f"‚Ä¢ `\"trading\"`\n\n"
                        f"**Syntaxe Regex:**\n"
                        f"‚Ä¢ `@\\S+` (mentions)\n"
                        f"‚Ä¢ `(bitcoin|crypto)` (mots multiples)",
                        parse_mode='markdown'
                    )
                    # Stocker l'√©tat en attente
                    telefeed_manager.sessions[f"pending_whitelist_{event.sender_id}"] = {
                        'action': action,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
                    
                elif action == 'remove':
                    if phone in telefeed_manager.whitelist:
                        if redirection_id in telefeed_manager.whitelist[phone]:
                            del telefeed_manager.whitelist[phone][redirection_id]
                            telefeed_manager.save_all_data()
                            await event.reply(f"‚úÖ Whitelist supprim√©e pour {redirection_id}")
                        else:
                            await event.reply(f"‚ùå Whitelist introuvable pour {redirection_id}")
                    else:
                        await event.reply(f"‚ùå Aucune whitelist pour {phone}")
                        
                elif action == 'change':
                    await event.reply(
                        f"üîß Modification whitelist pour **{redirection_id}**\n\n"
                        f"Envoyez les nouveaux mots/phrases:",
                        parse_mode='markdown'
                    )
                    telefeed_manager.sessions[f"pending_whitelist_{event.sender_id}"] = {
                        'action': action,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
            else:
                await event.reply("‚ùå Syntaxe incorrecte. Utilisez: /whitelist action redirectionid on phonenumber")
                
        elif len(parts) >= 2 and parts[0] == 'active':
            phone = parts[-1]
            whitelists = telefeed_manager.whitelist.get(phone, {})
            
            message = f"‚úÖ **Whitelists actives pour {phone}:**\n\n"
            if not whitelists:
                message += "üì≠ Aucune whitelist active"
            else:
                for redir_id, rules in whitelists.items():
                    message += f"üì° **{redir_id}:** {len(rules)} r√®gles\n"
            
            await event.reply(message, parse_mode='markdown')
            
        elif len(parts) >= 2 and parts[0] == 'clear':
            phone = parts[-1]
            if phone in telefeed_manager.whitelist:
                del telefeed_manager.whitelist[phone]
                telefeed_manager.save_all_data()
                await event.reply(f"‚úÖ Toutes les whitelists supprim√©es pour {phone}")
            else:
                await event.reply(f"‚ùå Aucune whitelist pour {phone}")
        else:
            await event.reply("‚ùå Syntaxe incorrecte. Consultez /help pour les exemples")
    
    # Commande /blacklist (similaire √† whitelist)
    @bot.on(events.NewMessage(pattern=r'/blacklist (.*)'))
    async def blacklist_handler(event):
        """Handler pour la commande /blacklist"""
        if not is_user_authorized(event.sender_id):
            await event.reply("‚ùå Vous devez avoir une licence active pour utiliser TeleFeed.")
            return
        
        command_args = event.pattern_match.group(1).strip()
        parts = command_args.split()
        
        if len(parts) >= 2 and parts[0] in ['add', 'remove', 'change']:
            action = parts[0]
            
            if ' on ' in command_args:
                remaining = command_args.replace(f'{action} ', '', 1)
                redirection_id, phone = remaining.split(' on ', 1)
                redirection_id = redirection_id.strip()
                phone = phone.strip()
                
                if action == 'add':
                    await event.reply(
                        f"‚ùå Configuration blacklist pour **{redirection_id}**\n\n"
                        f"Envoyez les mots/phrases √† bloquer (un par ligne):\n\n"
                        f"**Syntaxe Simple:**\n"
                        f"‚Ä¢ `\"spam\"`\n"
                        f"‚Ä¢ `\"publicit√©\"`\n\n"
                        f"**Syntaxe Regex:**\n"
                        f"‚Ä¢ `@\\S+` (mentions)\n"
                        f"‚Ä¢ `(spam|pub)` (mots multiples)",
                        parse_mode='markdown'
                    )
                    # Stocker l'√©tat en attente
                    telefeed_manager.sessions[f"pending_blacklist_{event.sender_id}"] = {
                        'action': action,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
                    
                elif action == 'remove':
                    if phone in telefeed_manager.blacklist:
                        if redirection_id in telefeed_manager.blacklist[phone]:
                            del telefeed_manager.blacklist[phone][redirection_id]
                            telefeed_manager.save_all_data()
                            await event.reply(f"‚úÖ Blacklist supprim√©e pour {redirection_id}")
                        else:
                            await event.reply(f"‚ùå Blacklist introuvable pour {redirection_id}")
                    else:
                        await event.reply(f"‚ùå Aucune blacklist pour {phone}")
                        
                elif action == 'change':
                    await event.reply(
                        f"üîß Modification blacklist pour **{redirection_id}**\n\n"
                        f"Envoyez les nouveaux mots/phrases:",
                        parse_mode='markdown'
                    )
                    telefeed_manager.sessions[f"pending_blacklist_{event.sender_id}"] = {
                        'action': action,
                        'redirection_id': redirection_id,
                        'phone': phone,
                        'timestamp': datetime.now().isoformat()
                    }
            else:
                await event.reply("‚ùå Syntaxe incorrecte. Utilisez: /blacklist action redirectionid on phonenumber")
                
        elif len(parts) >= 2 and parts[0] == 'active':
            phone = parts[-1]
            blacklists = telefeed_manager.blacklist.get(phone, {})
            
            message = f"‚ùå **Blacklists actives pour {phone}:**\n\n"
            if not blacklists:
                message += "üì≠ Aucune blacklist active"
            else:
                for redir_id, rules in blacklists.items():
                    message += f"üì° **{redir_id}:** {len(rules)} r√®gles\n"
            
            await event.reply(message, parse_mode='markdown')
            
        elif len(parts) >= 2 and parts[0] == 'clear':
            phone = parts[-1]
            if phone in telefeed_manager.blacklist:
                del telefeed_manager.blacklist[phone]
                telefeed_manager.save_all_data()
                await event.reply(f"‚úÖ Toutes les blacklists supprim√©es pour {phone}")
            else:
                await event.reply(f"‚ùå Aucune blacklist pour {phone}")
        else:
            await event.reply("‚ùå Syntaxe incorrecte. Consultez /help pour les exemples")
    
    print("‚úÖ Handlers TeleFeed enregistr√©s avec succ√®s!")